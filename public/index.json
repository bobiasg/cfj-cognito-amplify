[
{
	"uri": "//localhost:1313/",
	"title": "Authentication with AWS Cognito",
	"tags": [],
	"description": "",
	"content": "Authentication with AWS Cognito Welcome Amazon Cognito is an identity platform that helps developers set up customer identity and access management (CIAM) for web and mobile apps. It allows users to sign up, sign in, and access applications, web portals, or digital services. Cognito acts as a user directory, authentication server, and authorization service. It can authenticate and authorize users from a built-in user directory, an enterprise directory, or consumer identity providers like Google and Facebook.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "//localhost:1313/4_lab_3_identity_pool/41_create_identity_pool.html",
	"title": "Create Identity Pool",
	"tags": [],
	"description": "",
	"content": "Create Identity Pool From main Cognito page in the AWS console, Select Grant access to AWS services and then select Create identity pool You will see a page saying Identify the IAM roles to use with your new pool. Click on the Allow button to accept the defaults roles. You will now see the Getting Started with Amazon Cognito page. Click on the Platform dropdown button and select JavaScript. Make a note of the region and the IdentityPoolId because you will need these values for your JavaScript code. Navigate to IAM, Roles and type Cognito in the search bar. You should see the roles that Cognito automatically created for you when you enabled the Identity Pool. Select the IAM role with Auth in the name and edit this policy to allow listing files in S3. Don’t edit the Unauth policy as this is for unauthenticated users. Create S3 Ducket For Testing\nCreate S3 bucket and create two sub-directories “Engineering”, “Legal” Upload some test files in the bucket and sub-directories Edit bucket CORS permissions to allow cross-origin calls Important: This is for testing only, in production or real-world scenario you need to have proper CORS settings that allow only trusted origin.\n[\r{\r\u0026quot;AllowedHeaders\u0026quot;: [\u0026quot;*\u0026quot;],\r\u0026quot;AllowedMethods\u0026quot;: [\u0026quot;GET\u0026quot;],\r\u0026quot;AllowedOrigins\u0026quot;: [\u0026quot;*\u0026quot;],\r\u0026quot;ExposeHeaders\u0026quot;: []\r}\r]\r"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/21_create_user_pool.html",
	"title": "Create User Pool",
	"tags": [],
	"description": "",
	"content": "Log into the AWS Console. In the AWS Console, open Amazon Cognito . Then click “Create a user pool” in the top right Select “User name, Email” under Cognito user pool sign-in options and hit Next Select “No MFA” and hit Next Leave the defaults for Step 3 and hit Next\nSet Send email with Cognito and hit Next Enter your User pool Name to “CFJ-01”, Check the Use the Cognito Hosted UI option You can specify a custom domain name for example auth.mycompany.com or use a subdomain of the AWS Cognito service ( amazoncognito.com ). Pick and enter random/unique subdomain. Enter your App client name to \u0026ldquo;cfj-client\u0026rdquo; and enter the Allowed callbak URLs to “https://localhost”, then hit Next Finally in the last step choose Create user pool "
},
{
	"uri": "//localhost:1313/3_lab_2_access_api/31_deploy_mock_api.html",
	"title": "Deploy Mock API",
	"tags": [],
	"description": "",
	"content": "Deploy Mock API In the AWS Console, in the unified search type API Gateway and click on the API Gateway Service icon. Select REST API by clicking Build Then select Example API and click Create API. The Mock API and endpoints are ready configure Enable CORS And deploy. We will now define a stage, click the deployment stage combobox and select [New Stage]. Provide a Stage name*, for this example use Prod, then click deploy. You will see the API endpoint that has been deployed, you can click on this and see the result of a get request in the browser, Change the URL and append /pets to the end and press enter you will see an example JSON response. An example URL will look like so: https://{random}.execute-api.{region}.amazonaws.com/prop/pets We now have a mock API the provides static pet data, next we will add authentication restricted by OAuth scope.\n"
},
{
	"uri": "//localhost:1313/1_moduleone.html",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction What you\u0026rsquo;ll be building Implementing Authentication in a Next.js 14 Application with AWS Cognito and NextAuth Integration\nWhen building a Next.js 14 application, implementing robust authentication is crucial for securing user data and managing access to various parts of your application. By integrating AWS Cognito with the NextAuth library, you can create a seamless sign-in/sign-up experience that leverages AWS\u0026rsquo;s secure and scalable user authentication service.\nIn this workshop, we’ll walk through how to set up Cognito for a simple web app. We’ll perform these steps:\nCreate a Cogni1to user pool Add sign-up and sign-in pages Assign IAM roles to authenticated users Access AWS resources from the app This workshop should take you anywhere between 1 to 4 hours to complete.\nWhat you will learn During this workshop you use multiple AWS services including:\nAmazon Cognito Amazon Amplify Amazon API Gateway TOC Getting Started Setting up AWS Cognito Implement sign-up and sign-in page Implement access AWS resources from the app The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "//localhost:1313/1_moduleone/11_introduction_cognito.html",
	"title": "Introduction to Cognito",
	"tags": [],
	"description": "",
	"content": "Introduction to Cognito Amazon Cognito lets you easily add user sign-up and authentication to your mobile and web apps. Amazon Cognito also enables you to authenticate users through an external identity provider and provides temporary security credentials to access your app’s backend resources in AWS or any service behind Amazon API Gateway. Amazon Cognito works with external identity providers that support SAML or OpenID Connect, social identity providers (such as Facebook, Apple, Amazon) and you can also integrate your own identity provider.\nImage Source: Jerry Hargrove, awsgeek.com. License\nThe two components that follow make up Amazon Cognito. They operate independently or in tandem, based on your access needs for your users.\nUser pools Image Source: Amazon Docs\nCreate a user pool when you want to authenticate and authorize users to your app or API. User pools are a user directory with both self-service and administrator-driven user creation, management, and authentication. Your user pool can be an independent directory and OIDC identity provider (IdP), and an intermediate service provider (SP) to third-party providers of workforce and customer identities. You can provide single sign-on (SSO) in your app for your organization\u0026rsquo;s workforce identities in SAML 2.0 and OIDC IdPs with user pools. You can also provide SSO in your app for your organization\u0026rsquo;s customer identities in the public OAuth 2.0 identity stores Amazon, Google, Apple and Facebook. For more information about customer identity and access management (CIAM), see What is CIAM?.\nUser pools don’t require integration with an identity pool. From a user pool, you can issue authenticated JSON web tokens (JWTs) directly to an app, a web server, or an API.\nIdentity pools Image Source: Amazon Docs\nSet up an Amazon Cognito identity pool when you want to authorize authenticated or anonymous users to access your AWS resources. An identity pool issues AWS credentials for your app to serve resources to users. You can authenticate users with a trusted identity provider, like a user pool or a SAML 2.0 service. It can also optionally issue credentials for guest users. Identity pools use both role-based and attribute-based access control to manage your users’ authorization to access your AWS resources.\nIdentity pools don’t require integration with a user pool. An identity pool can accept authenticated claims directly from both workforce and consumer identity providers.\n"
},
{
	"uri": "//localhost:1313/3_lab_2_access_api/32_create_cognito_authorizer.html",
	"title": "Create Cognito Authorizer",
	"tags": [],
	"description": "",
	"content": "Cognito Authorizer Create Cognito Authorizer In API Gateway on the left menu click Authorizers , then click + Create New Authorizer input the name as cfj-ws-01, select Cognito and select your Cognito user pool in the drop down ( this should pre-populate when you click in the input field ).\nAdditionally add Authorization as the Token Source, ( note the spelling is Authorization ). Finally, click Create authorizer Your new Authorizer is ready, but before we attach this to the API let’s explore the test functionality. Click Test authorizer. This will bring up a dialog, this is expecting what we would send to the API in an Authorization header. We will send a Bearer token that was generated earlier in Postman. Leave this dialog open. Return to Postman, click Get New Access Token to retrieve a new token. Return to the AWS Console and in the input box type Bearer with one space and then paste the token and click Test authorizer. Your Authorizer works end to end, now lets test this against the actual API. Attach Authorizer to the API We now have all the parts to add authentication to the API. In this section we will restrict access to the /pets end point.\nTo confirm this is all working as expected return to Postman and open a new tab, take the API URL ( you should still have this in a browser tab, if not navigate back to API Gateway, click Stages in the left menu and copy the URL from the highlighted section at the top next to Invoke URL ) and paste this in, click send to see the result Return to the AWS Console, Navigate to API Gateway and select your API. In the left hand menu click Resources, in the Resources column, click/expand /pets then click on GET we will add authentication to only this resource which is the http GET verb on the sample API resource. Note: You may have to refresh the webpage for this new Click on the Authorization combo box, select cfj-ws-01 (You may have refresh the page if you do not see it), add a new option OAuth Scopes: cfj/read, this is the OAuth scope we defined in Cognito earlier. Click the small tick to save. You screen should look like below: The settings are now ready but we have to deploy our API changes, click on Actions then Deploy API, for the deployment stage select prod and click deploy "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication.html",
	"title": "Lab 1 - User Pool API Authentication",
	"tags": [],
	"description": "",
	"content": "Lab 1 - User Pool API Authentication In this Lab you will setup a User Pool with a Hosted UI. You will explore OpenID and different approaches on how to configure and test OAuth 2.0. And we will implement it in nextjs app.\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.. Diagram\n"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/22_user_pool_configuration.html",
	"title": "User Pool Configuration",
	"tags": [],
	"description": "",
	"content": " Resouce Server We are now ready to further configure our user pool, we will begin by adding a resource server. As this lab will grant access to a Mock API at this stage we will create the resource and scope that will provide authenticated access to the get method of the API.\nSelect the App Integration tab and click on Create resource server Next we will enter as above the Resource server name, server identifier and Scope name then select Create resource server. App Client Settings We will now configure the call back URLs, OAuth flows and OAuth scopes.\nScroll down while still in the App integration tab to App client list and click on cfj-client” Then under Hosted UI select Edit There are a number of options to enable, ensure yours look the same as the image.\nFirst we add the Allowed sign-out URL to https://localhost\nUnder OAuth 2.0 Grant Types select\nAuthorization code grant and Implicit grant The implicit grant flow exposes OAuth tokens in the url. Although we are using it here for testing purposes only, we strongly reocmmend you only use the authroization code flow with PKCE for public clients.\nUnder OpenID Connect Scopes select\nOpenID Profile Email Under Custom Scopes select\ncfj-01/read Finally click Save changes\n"
},
{
	"uri": "//localhost:1313/1_moduleone/12_why_use_cognito.html",
	"title": "Why use Cognito",
	"tags": [],
	"description": "",
	"content": "Why use Cognito Integration with Other AWS Services Currently, there are many user management platforms, such as Clerk, Auth0, and others, that offer authentication features. Each of these services has unique advantages compared to AWS Cognito. However, when an application requires access to AWS resources, it’s essential to implement proper authorization and use Developer credentials/SDK to interact with those resources.\nCognito integrates seamlessly with other AWS services like API Gateway, Lambda, S3, and DynamoDB. This allows you to build comprehensive, robust, scalable, serverless applications where authentication and authorization are tightly coupled with your backend services.\nSource Image: Amazon Blog\nBenefits as cloud service "
},
{
	"uri": "//localhost:1313/3_lab_2_access_api/33_access_api_nextjs.html",
	"title": "Access API in NextJS",
	"tags": [],
	"description": "",
	"content": "Access API in NextJS Postman To confirm this is all working as expected return to Postman, the same tab from earlier will be open, click Send to call the api again. This time the response will be: This is expected, the API now require authorisation!\nYou can manually add this by extracting the token as in earlier steps when we tested the Authorizer in the API Gateway console or you can click on the Authorization tab, for type select OAuth 2.0 This should re-populate the settings we entered. Available tokens will be empty, scroll down and click Get New Token, put in the username and password of the user created. Click Proceed, this time once the Manage Access Tokens dialog appears click Use Token.\nClick on the Headers tab and notice the additional header key and value. Click Send and the API will again return data! NextJS App After sign-in and getting tokens, you can use these tokens to authorize access to protected APIs on API Gateway.\nThis exercise is based on the APIs that has been created in 2. User Pool API Authentication.\nImportant: Make sure that you have an API that uses Cognito authorizer for authorization using id_token. Remove Oauth Scopes from authorizer settings. Deploy to prod stage once done.\nAdd button in dashboard page:\nconst makeRequestWithToken = async () =\u0026gt; { try { const response = await fetch(\u0026#39;https://06gfqqzl55.execute-api.ap-southeast-1.amazonaws.com/prod/pets\u0026#39;,{ method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer \u0026#39; + session?.accessToken, }, }) const data = await response.json() setApiResponse(JSON.stringify(data, null, 2)) } catch (error) { setApiResponse(\u0026#34;Failed to fetch data: \u0026#34; + error) } } You can now test invoking the API, after you sign-in with \u0026ldquo;Google\u0026rdquo; and get tokens from Cognito, click the Make API Request button. Notice the access-token is added to the authorization header and the endpoint responds with the expected results: Currently, when you sign in by username/password, you will get error because in crendentials process, we does not process to request scope: cfj/read "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/23_explore_openid_hosted_ui.html",
	"title": "Explore OpenID Config and Hosted UI",
	"tags": [],
	"description": "",
	"content": " OpenID Config Lets explore the published configuration and it’s format. This configuration follows a convention\nhttps://cognito-idp.{region}.amazonaws.com/{userpoolid}/.well-known/openid-configuration\nOn the console, on the left menu click on General settings, here you will find the user pool id: Copy this to construct your OpenID config URL and open this in your browser. https://cognito-idp.ap-southeast-1.amazonaws.com/ap-southeast-1_3JmHkB1jl/.well-known/openid-configuration\nHosted UI Lets explore the hosted UI and options.\nReturn to the AWS Console, Under the tab App integration click on cfj-client. From here click on View Hosted UI this will open a window/tab. Link will be https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=code\u0026amp;scope=cfj%2Fread\u0026#43;email\u0026#43;openid\u0026#43;profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nIn the New tab click Sign up we will be registering a new user. Fill out the registration form and ensure you use a real email address as a OTP ( One Time Password ) will be sent to this address to enable account confirmation. Click Sign up\nCheck your email inbox for the OTP and enter the value and click Confirm Account. The email you receive is minimal and not styled; this can all be customised if required. Once your account is confirmed you will be redirected back to your application, as we configured that url for this exercise to localhost and we are not hosting an application your browser will display the following. Take note of the URL it will be: https://localhost/?code=5768f05d-9077-4acb-a4d6-4978923f1995 though will be a different code. Let’s now look at the response when we change to implicit flow sign in. Change the response type value to token from code https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=token\u0026amp;scope=cfj%2Fread+email+openid+profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nAnd press enter to load the new URL, enter the user details you created previously and click Sign in “https://localhost/#id_token={a-large-id-token}\u0026amp;access_token={a-large-access-token}\u0026amp;expires_in=3600\u0026amp;token_type=Bearer” because your browser can’t connect to the server “localhost”.\nAuthorization in Postman Once postman launches, click the + to open a new tab. Once we have a new tab, click on the Authorisation item, then change the type to OAuth 2.0 Fill out the settings as per below, the Callback URL will be: https://localhost The Auth URL’s will be: https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/authorize and https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/token This can be found by navigating in Cognito console to App integration tab. Then in there, look for Cognito domain. The Client ID can be found by scrolling down in the App integration page to App client and analytics section. The ID will be listed next to your App client name.\nThen click Get New Access Token. This will pop up a mini browser requesting your credentials, use the credentials you created earlier to login and click Sign in. The mini browser will close and if you have followed all the steps correctly you will see this message: Click Proceed to view the tokens returned by Cognito. The token returned can be decoded at https://jwt.io for closer inspection this token is used to send to our service to authenticate and and provide course level access as defined by the scope. An example can be seen below. "
},
{
	"uri": "//localhost:1313/1_moduleone/13_how_authentication_works.html",
	"title": "How authentication works",
	"tags": [],
	"description": "",
	"content": "How authentication works with Amazon Cognito user pools and identity pools When your customer signs in to an Amazon Cognito user pool, your application receives JSON web tokens (JWTs).\nWhen your customer signs in to an identity pool, either with a user pool token or another provider, your application receives temporary AWS credentials.\nWith user pool sign-in, you can implement authentication and authorization entirely with an AWS SDK. If you don\u0026rsquo;t want to build your own user interface (UI) components, you can invoke a prebuilt web UI (the hosted UI) or the sign-in page for your third-party identity provider (IdP).\nUser pool API authentication and authorization with an AWS SDK API authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. They enter their username and password. The application invokes the method that makes an InitiateAuth API request. The request passes the user\u0026rsquo;s credentials to a user pool. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The user pool responds with a challenge that requests an MFA code. The application generates a prompt that collects the MFA code from the user. The application invokes the method that makes a RespondToAuthChallenge API request. The request passes the user\u0026rsquo;s MFA code. The user pool validates the user\u0026rsquo;s MFA code. The user pool responds with the user\u0026rsquo;s JWTs. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It invokes the InitiateAuth method again with the refresh token and retrieves new tokens. User pool authentication with the hosted UI Hosted UI authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a hosted UI sign-in prompt. They enter their username and password. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The hosted UI prompts the user to enter an MFA code. The user enters their MFA code. The hosted UI redirects the user to the application. The application collects the authorization code from the URL request parameter that the hosted UI appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. User pool authentication with a third-party identity provider Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The IdP prompts the user to enter an MFA code. The user enters their MFA code. The IdP redirects the user to the user pool with a SAML response or an authorization code. If the user passed an authorization code, the user pool silently exchanges the code for IdP tokens. The user pool validates the IdP tokens and redirects the user to the application with a new authorization code. The application collects the authorization code from the URL request parameter that the user pool appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. Identity pool authentication Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials. The IdP redirects the user to the application with a SAML response or an authorization code. If the user passed an authorization code, the application exchanges the code for IdP tokens. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs or assertion. The application invokes the method that makes a GetId API request. It passes the user\u0026rsquo;s token or assertion and requests an identity ID. The identity pool validates the token or assertion against configured identity providers. The identity pool returns an identity ID. The application invokes the method that makes a GetCredentialsForIdentity API request. It passes the user\u0026rsquo;s token or assertions and requests an IAM role. The identity pool generates a new JWT. The new JWT contains claims that request an IAM role. The identity pool determines the role based on the user\u0026rsquo;s request and the role-selection criteria in the identity pool configuration for the IdP. AWS Security Token Service (AWS STS) responds to the AssumeRoleWithWebIdentity request from the identity pool. The response contains API credentials for a temporary session with an IAM role. The application stores the session credentials. The user takes an action in the app that requires access-protected resources in AWS. The application applies the temporary credentials as signatures to API requests for the required AWS services. IAM evaluates the policies attached to the role in the credentials. It compares them to the request. The AWS service returns the requested data. The application renders the data in the user\u0026rsquo;s interface. The user views the data. "
},
{
	"uri": "//localhost:1313/3_lab_2_access_api.html",
	"title": "Lab 2 - Access Protected API",
	"tags": [],
	"description": "",
	"content": "Access Protected API We will now deploy a Mock API and configure access to the read resource of that API. API has protected by Cognito Authorizer in API Gateway.\n"
},
{
	"uri": "//localhost:1313/4_lab_3_identity_pool.html",
	"title": "Lab 3 - Identity Pool",
	"tags": [],
	"description": "",
	"content": "Lab 3 - Identity Pool Setup and Explore User Pools SDK Coding Exercise "
},
{
	"uri": "//localhost:1313/1_moduleone/14_workshopprerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites This lab requires access to the AWS Console with a role that contains full permissions to:\nThe AWS Console Cognito API Gateway You will also require tools such as:\nnodejs Postman https://www.postman.com/ "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/25_restricting_api_access_.html",
	"title": "Restricting Api Access",
	"tags": [],
	"description": "",
	"content": "Deploy a mock API We will now deploy a Mock API and configure access to the read resource of that API.\nIn the AWS Console, in the unified search type API Gateway and click on the API Gateway Service icon. If this is your first visit to API Gateway you will see the welcome page, click Get Started You will be prompted with a dialog to deploy a prepopulated mock API, click OK You can peruse the Example API response, when you are satisfied, leave all settings as defaults and click Import If you have used API Gateway before, click Create API \u0026hellip;\u0026hellip;\nCreate Cognito Authorizer In API Gateway on the left menu click Authorizers , then click + Create New Authorizer input the name as Builder-Class, select Cognito and select your Cognito user pool in the drop down ( this should pre-populate when you click in the input field ).\nAdditionally add Authorization as the Token Source, ( note the spelling is Authorization ). Finally, click Create Your new Authorizer is ready, but before we attach this to the API let’s explore the test functionality. Click Test This will bring up a dialog, this is expecting what we would send to the API in an Authorization header. We will send a Bearer token that was generated earlier in Postman. Leave this dialog open. Return to Postman and return to the original Tab, Click Auth then click on the Available Tokens combo box, click Manage Tokens. From here scroll down until you see Token Type Bearer select and copy this token into your clipboard. If you double click the token it will select it all, do this carefully as the token is long. If you have left this idle for too long you may need to click Get New Access Token to retrieve a new token. Return to the AWS Console and in the input box type Bearer with one space and then paste the token and click test. Your Authorizer works end to end, now lets test this against the actual API. Attach Authorzier to the API We now have all the parts to add authentication to the API. In this section we will restrict access to the /pets end point.\nTo confirm this is all working as expected return to Postman and open a new tab, take the API URL ( you should still have this in a browser tab, if not navigate back to API Gateway, click Stages in the left menu and copy the URL from the highlighted section at the top next to Invoke URL ) and paste this in, click send to see the result. Return to the AWS Console, Navigate to API Gateway and select your API. In the left hand menu click Resources, in the Resources column, click/expand /pets then click on GET we will add authentication to only this resource which is the http GET verb on the sample API resource. Note: You may have to refresh the webpage for this new resource to appear. Click on the Authorization combo box select Builder-class (You may have refresh the page if you do not see it), then click the little tick to save. This will deploy a new option OAuth Scopes, click next to the default value which is NONE and type in petstore/read this is the OAuth scope we defined in Cognito earlier. Click the small tick to save. You screen should look like below: The settings are now ready but we have to deploy our API changes, click on Actions then Deploy API for the deployment stage select Prod and click deploy Test access api in postman To confirm this is all working as expected return to Postman, the same tab from earlier will be open, click Send to call the api again. This time the response will be:\nThis is expected, the API now require authorisation!\nThe API is expecting a new http header, the header required is: ` Key: Authorization Value: Bearer token\n`\nYou can manually add this by extracting the token as in earlier steps when we tested the Authorizer in the API Gateway console or you can click on the Authorization tab, for type select OAuth 2.0 This should re-populate the settings we entered. Available tokens will be empty, scroll down and click Get New Token, put in the username and password of the user created. Click Proceed, this time once the Manage Access Tokens dialog appears click Use Token. Click on the Headers tab and notice the additional header key and value. Click Send and the API will again return data! Create an IAM Role for your workspace Submodule Three Heading This paragraph block can be used to explain how to create a workspace if necessary. Example content guidance can be found at the bottom of the page.\nNext Section Heading This paragraph block can optionally be utilized to lead into the next section of the workshop.\nExample Content Guidance Create an IAM Role for your workspace Info: Starting from here, when you see command to be entered such as below, you will enter these commands into Cloud9 IDE. You can use the Copy to clipboard feature (right hand upper corner) to simply copy and paste into Cloud9. In order to paste, you can use Ctrl + V for Windows or Command + V for Mac.\nFollow this deep link to create an IAM role with Administrator access.\rConfirm that AWS service and EC2 are selected, then click Next to view permissions.\rConfirm that AdministratorAccess is checked, then click Next to review.\rEnter CircleCI-Workshop-Admin for the Name, and select Create Role createrole\r"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/26_create_nextjs_app.html",
	"title": "Nextjs App With NextAuth",
	"tags": [],
	"description": "",
	"content": " Nextjs App With NextAuth Create NextJs App To get started, we first need to create a new Next.js project.\n$ npx create-next-app@latest cfj-cognito\rNow change into the new app directory \u0026amp; install some dependencies\nnpm install next-auth@beta\rConfigure NextAuth Create auth secret, it will add AUTH_SECRET to .env.local\nnpx auth secret\rCreate file auth.ts in folder libs, place the follwing content inside:\nimport NextAuth from \u0026#34;next-auth\u0026#34;; import CognitoProvider from \u0026#34;next-auth/providers/cognito\u0026#34;; export const { handlers, signIn, signOut, auth } = NextAuth({ // Configure one or more authentication providers providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, }), ], }) Create file route.ts in folder named app/api/auth/[\u0026hellip;nextauth] with content:\nimport {handlers} from \u0026#39;@/libs/auth\u0026#39;; export const {GET, POST} = handlers; As you can observe in the code snippet, all sensitive information is stored in an .env.local file. This practice is essential to prevent exposure of such details to the front-end users of our application. COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET get from App Client Setting in Cognito User Pool.\nFirst, go back to AWS -\u0026gt; Cognito and select \u0026ldquo;CFJ-01\u0026rdquo; pool.\nClick on the App integration tab and scroll to the bottom. You will see the App client list. Great! Here, you should find your \u0026ldquo;cfj-client\u0026rdquo;. Click on it. This is the place where you want to be: The issuer is a URL, that looks like this: https://cognito-idp.{region}.amazonaws.com/{PoolId}, where PoolId is from General Settings in Cognito Implementing User Authentication This section is extra, so enjoy it! First, create a new file inside app called auth-provider.tsx and put the following code inside:\n\u0026#34;use client\u0026#34;; import { SessionProvider } from \u0026#34;next-auth/react\u0026#34;; export default function AuthProvider({ children }: { children: React.ReactNode }) { return \u0026lt;SessionProvider\u0026gt;{children}\u0026lt;/SessionProvider\u0026gt;; } Update app/layout.tsx\nimport type { Metadata } from \u0026#34;next\u0026#34;; import { Inter } from \u0026#34;next/font/google\u0026#34;; import \u0026#34;./globals.css\u0026#34;; import AuthProvider from \u0026#34;@/components/auth-provider\u0026#34;; import Header from \u0026#34;@/components/header\u0026#34;; import Footer from \u0026#34;@/components/footer\u0026#34;; const inter = Inter({ subsets: [\u0026#34;latin\u0026#34;] }); export const metadata: Metadata = { title: \u0026#34;Create Next App\u0026#34;, description: \u0026#34;Generated by create next app\u0026#34;, }; export default function RootLayout({ children, }: Readonly\u0026lt;{ children: React.ReactNode; }\u0026gt;) { return ( \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body className={inter.className}\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col justify-between w-full h-full min-h-screen\u0026#34;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;AuthProvider\u0026gt; \u0026lt;main className=\u0026#34;flex-auto w-full max-w-3xl px-4 py-4 mx-auto sm:px-6 md:py-6\u0026#34;\u0026gt; {children} \u0026lt;/main\u0026gt; \u0026lt;/AuthProvider\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ); } Update app/page.tsx\nimport { auth } from \u0026#34;@/libs/auth\u0026#34; export default async function Index() { const session = await auth() return ( \u0026lt;div className=\u0026#34;flex flex-col gap-6\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-3xl font-bold\u0026#34;\u0026gt;NextAuth.js Example\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; This is an example site to demonstrate how to use NextAuth with Cognito \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col bg-gray-100 rounded-md\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;p-4 font-bold bg-gray-200 rounded-t-md\u0026#34;\u0026gt; Current Session \u0026lt;/div\u0026gt; \u0026lt;pre className=\u0026#34;py-6 px-4 whitespace-pre-wrap break-all\u0026#34;\u0026gt; {JSON.stringify(session, null, 2)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } For make some styles on app, I add more components and library. I can access code at \u0026hellip;\u0026hellip;.\nTesting To run app in https mode, update package.json in scripts tag:\n\u0026quot;dev\u0026quot;: \u0026quot;next dev --experimental-https\u0026quot;,\rRun app\nnpm run dev\rIt open page in browser at https://localhost:3000 Click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign in with Cognito\u0026rdquo;, browser will be redirect to hosted UI site. But now, we got error by redirect missmatch. Go to Hosted UI setting to update callback Url. Add new callback url: https://localhost:3000/api/auth/callback/cognito We will access test app again at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign In with Cognito\u0026rdquo; to process authentication at Hosted UI site Enter your crendentials, after authenticated, browser will be redirect to https://localhost:3000 "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/27_social_login.html",
	"title": "Third Party Identity Provider",
	"tags": [],
	"description": "",
	"content": " Third Party Identity Provider Cognito user pools also allow you to set up social login for your users. This is very convenient in a world where most people have become accustomed to authentication via existing accounts such as Google, Facebook, Apple, etc. Source Image: https://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc\nSocial login setup To add google for authentication, we need to create OAuth client ID in Google API console. Open browser to access https://console.cloud.google.com/, select a project or create new project if not exists, and select \u0026ldquo;API \u0026amp; Service\u0026rdquo; in overview of project. Select \u0026ldquo;Credentials\u0026rdquo; tab and click \u0026ldquo;Create Crendentials\u0026rdquo; to create new OAuth Client Select Applicatio Type is Web Application, Enter name and set redirect Url. Redirect URI should be set to https:///oauth2/idpresponse. Click \u0026ldquo;Create\u0026rdquo; to create new crendentials. Store Client Id and Client Secret for setup in AWS Cognito. Go to \u0026ldquo;CFJ-01\u0026rdquo; User Pool, tab \u0026ldquo;Sign-in experience\u0026rdquo;, click \u0026ldquo;Add identity provider\u0026rdquo; Select \u0026ldquo;Google\u0026rdquo; and provider Client Id and Client Secret that has created above. Click \u0026ldquo;Add identity provider\u0026rdquo; to create Federated identity provider sign-in Login with Hosted UI We need to edit Hosted UI for using Google Authentication. In \u0026ldquo;CFJ-01\u0026rdquo; User pool, Select \u0026ldquo;cfj-client\u0026rdquo;, Click \u0026ldquo;Edit\u0026rdquo; on Hosted UI tab, add \u0026ldquo;Google\u0026rdquo; in \u0026ldquo;Identity provider\u0026rdquo; Click \u0026ldquo;Save\u0026rdquo;, it return to app client overview. On Hosted UI tab, Click \u0026ldquo;View Hosted UI\u0026rdquo; to see new Sign in with Google. Now you can authenticate with google in intergrated AWS Cognito.\nSeamless auth experience Now, we can authenticate users with Google, but they need to go to the Hosted UI site to continue with Google authentication. We will improve this by bypassing the Cognito-hosted UI for a seamless authentication experience for the user.\nAdd new provider in Next Auth configuration in libs/auth.ts\n.... providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, authorization: { params: { scope: \u0026#34;email profile openid cfj/read\u0026#34; } } }), ...([\u0026#34;Google\u0026#34;] as TProvider[]).map((providerName: TProvider) =\u0026gt; { const provider: Provider = getProvider(providerName); (provider as OAuth2Config\u0026lt;Profile\u0026gt;).authorization.params.scope = \u0026#34;email profile openid cfj/read\u0026#34;; return provider; }) ], .... Update redirect Url in Hosted UI setting Open browser at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo; and select \u0026ldquo;Sign in with CognitoGoogle\u0026rdquo; In user\u0026rsquo;s view, browser redirect to social page (Google), after alowed by user, it redirect to nextjs, bypass Hosted UI site.\nFor username/password login, we use NextAuth credentials provider with the AWS Cognito library\nAdd Credentials provider to \u0026rsquo;libs/auth.ts'\nCredentials({ id: \u0026#39;credentials\u0026#39;, name: \u0026#39;credentials\u0026#39;, credentials: { username: { label: \u0026#39;username\u0026#39;, type: \u0026#39;text\u0026#39; }, password: { label: \u0026#39;password\u0026#39;, type: \u0026#39;password\u0026#39; } }, async authorize(credentials) { if (!credentials) return null; const {username, password} = credentials; const secretHash = computeSecretHash(username as string, process.env.COGNITO_CLIENT_ID as string, process.env.COGNITO_CLIENT_SECRET as string); const cognito = new CognitoIdentityProviderClient({region: process.env.COGNITO_REGION}); const command = new InitiateAuthCommand({ AuthFlow: \u0026#39;USER_PASSWORD_AUTH\u0026#39;, ClientId: process.env.COGNITO_CLIENT_ID as string, AuthParameters: { USERNAME: username as string, PASSWORD: password as string, SECRET_HASH: secretHash, }, }); try { const response = await cognito.send(command); // You can access the ID, Access, and Refresh tokens here const idToken = response.AuthenticationResult?.IdToken; const accessToken = response.AuthenticationResult?.AccessToken; const refreshToken = response.AuthenticationResult?.RefreshToken; const expiresIn = response.AuthenticationResult?.ExpiresIn; let user: User = {} if (accessToken) { const userCommand = new GetUserCommand({ AccessToken: accessToken, }); const userResponse = await cognito.send(userCommand); user.id = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;sub\u0026#39;)?.Value as string | undefined; user.email = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;email\u0026#39;)?.Value as string | undefined; user.name = userResponse.Username; } return { ...user, token: {idToken, accessToken, refreshToken, expiresIn} } as User; } catch (error) { console.error(error); return null; } }, }) Now, user authentication avoids redirection to external pages (Hosted UI site), thereby enhancing the user experience and interface (UX/UI). Reference: https://kelvinmwinuka.com/social-login-with-cognito-and-nextauth\nhttps://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc\nSource code: https://github.com/bobiasg/cfj-cognito\n"
},
{
	"uri": "//localhost:1313/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]