[
{
	"uri": "//localhost:1313/",
	"title": "Authentication with AWS Cognito",
	"tags": [],
	"description": "",
	"content": "Authentication with AWS Cognito Welcome Amazon Cognito is an identity platform that helps developers set up customer identity and access management (CIAM) for web and mobile apps. It allows users to sign up, sign in, and access applications, web portals, or digital services. Cognito acts as a user directory, authentication server, and authorization service. It can authenticate and authorize users from a built-in user directory, an enterprise directory, or consumer identity providers like Google and Facebook.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/21_create_user_pool.html",
	"title": "Create User Pool",
	"tags": [],
	"description": "",
	"content": "Log into the AWS Console. In the AWS Console, open Amazon Cognito . Then click “Create a user pool” in the top right Select “User name, Email” under Cognito user pool sign-in options and hit Next Select “No MFA” and hit Next Leave the defaults for Step 3 and hit Next\nSet Send email with Cognito and hit Next Enter your User pool Name to “CFJ-01”, Check the Use the Cognito Hosted UI option You can specify a custom domain name for example auth.mycompany.com or use a subdomain of the AWS Cognito service ( amazoncognito.com ). Pick and enter random/unique subdomain. Enter your App client name to \u0026ldquo;cfj-client\u0026rdquo; and enter the Allowed callbak URLs to “https://localhost”, then hit Next Finally in the last step choose Create user pool "
},
{
	"uri": "//localhost:1313/1_moduleone.html",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction What you\u0026rsquo;ll be building Implementing Authentication in a Next.js 14 Application with AWS Cognito and NextAuth Integration\nWhen building a Next.js 14 application, implementing robust authentication is crucial for securing user data and managing access to various parts of your application. By integrating AWS Cognito with the NextAuth library, you can create a seamless sign-in/sign-up experience that leverages AWS\u0026rsquo;s secure and scalable user authentication service.\nIn this workshop, we’ll walk through how to set up Cognito for a simple web app. We’ll perform these steps:\nCreate a Cogni1to user pool Add sign-up and sign-in pages Assign IAM roles to authenticated users Access AWS resources from the app This workshop should take you anywhere between 1 to 4 hours to complete.\nWhat you will learn During this workshop you use multiple AWS services including:\nAmazon Cognito Amazon Amplify Amazon API Gateway TOC Getting Started Setting up AWS Cognito Implement sign-up and sign-in page Implement access AWS resources from the app The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "//localhost:1313/1_moduleone/11_introduction_cognito.html",
	"title": "Introduction to Cognito",
	"tags": [],
	"description": "",
	"content": "Introduction to Cognito Amazon Cognito lets you easily add user sign-up and authentication to your mobile and web apps. Amazon Cognito also enables you to authenticate users through an external identity provider and provides temporary security credentials to access your app’s backend resources in AWS or any service behind Amazon API Gateway. Amazon Cognito works with external identity providers that support SAML or OpenID Connect, social identity providers (such as Facebook, Apple, Amazon) and you can also integrate your own identity provider.\nImage Source: Jerry Hargrove, awsgeek.com. License\nThe two components that follow make up Amazon Cognito. They operate independently or in tandem, based on your access needs for your users.\nUser pools Image Source: Amazon Docs\nCreate a user pool when you want to authenticate and authorize users to your app or API. User pools are a user directory with both self-service and administrator-driven user creation, management, and authentication. Your user pool can be an independent directory and OIDC identity provider (IdP), and an intermediate service provider (SP) to third-party providers of workforce and customer identities. You can provide single sign-on (SSO) in your app for your organization\u0026rsquo;s workforce identities in SAML 2.0 and OIDC IdPs with user pools. You can also provide SSO in your app for your organization\u0026rsquo;s customer identities in the public OAuth 2.0 identity stores Amazon, Google, Apple and Facebook. For more information about customer identity and access management (CIAM), see What is CIAM?.\nUser pools don’t require integration with an identity pool. From a user pool, you can issue authenticated JSON web tokens (JWTs) directly to an app, a web server, or an API.\nIdentity pools Image Source: Amazon Docs\nSet up an Amazon Cognito identity pool when you want to authorize authenticated or anonymous users to access your AWS resources. An identity pool issues AWS credentials for your app to serve resources to users. You can authenticate users with a trusted identity provider, like a user pool or a SAML 2.0 service. It can also optionally issue credentials for guest users. Identity pools use both role-based and attribute-based access control to manage your users’ authorization to access your AWS resources.\nIdentity pools don’t require integration with a user pool. An identity pool can accept authenticated claims directly from both workforce and consumer identity providers.\n"
},
{
	"uri": "//localhost:1313/3_modulethree/31_partnersetup.html",
	"title": "Partner Setup Instructions",
	"tags": [],
	"description": "",
	"content": "Partner Setup Instructions Submodule One Heading This paragraph block should be an introduction to the submodule.\nSubmodule One Subheading This paragraph block should be utilized to start the submodule. Next Section OR Conclusion Heading This paragraph block can be utilized to lead into the next section of the workshop (which might be a conclusion) or be a conclusion itself.\nExample Guidance Content Below Do you require attendees to sign up for things? Introduction In this section, we are going to discuss tasks and concepts like retrieving access tokens and other configurations within some integration services.\nDocker Hub Docker Hub is a service provided by Docker for finding and sharing container images with your team. It is the world’s largest repository of container images with an array of content sources including container community developers, open source projects and independent software vendors (ISV) building and distributing their code in containers.\nCreate a Docker Hub Access Token The pipeline will package the application into a Docker image. It then pushes that image a public Docker Hub image repository so that it will be available to the deployment segment of the pipeline. To push or upload the newly-built Docker image, the pipeline will need an access token to authorize transaction on your Docker Hub account. You will need to create a new access token (https://docs.docker.com/docker-hub/access-tokens/) and store it for use in later modules. To create your new access tokens:\nLog in to hub.docker.com\rClick your username in the top right corner and select Account Settings\rSelect Security \u0026gt; New Access Token.\rAdd a description for your token that indicates where the token will be used, or that sets a purpose for the token\rCopy the token that appears on the screen and record it in a safe location for use in future modules. Make sure you do this now! Once you close this prompt, Docker will never show the token again and you will have to create a new one\rWarning: Docker Hub credentials and access tokens must be protected and not shared with unauthorized parties to prevent exposure and unauthorized access.\nNow that you have created and safely recorded your new access token, let’s move to the next section and create a new Snyk Access token.\nSnyk Snyk is an open source security platform designed to help software-driven businesses enhance developer security. Snyk’s dependency scanner makes it the only solution that seamlessly and proactively finds, prioritizes, and fixes vulnerabilities and license violations in open source dependencies and container images.\nCreate Snyk Access Token Visit your Snyk account (Account Settings \u0026gt; API Token section) (https://app.snyk.io/account)\rIn the KEY field, select click to show, then select and copy your API token from the field\rPaste the token that appears on the screen in a safe location for use in future modules\rWarning: Your Snyk access token must be protected and not shared with unauthorized parties to prevent exposure and unauthorized access.\nYou can read more about Snyk Access Token from their docs here.\nGreat, you have created and safely stored your newly created Snyk access token, Now, let’s create the Terraform Cloud access token.\nTerraform Cloud Terraform Cloud is an application that helps teams use Terraform together. It manages Terraform runs in a consistent and reliable environment, and includes easy access to shared state and secret data, access controls for approving changes to infrastructure, a private registry for sharing Terraform modules, detailed policy controls for governing the contents of Terraform configurations, and more.\nYou will be using Terraform Cloud to store the Terraform state of the infrastructures your pipeline will provision and deploy using Terraform in future modules.\nCreate Terraform Cloud Access Token Create a `[Terraform Cloud ](https://app.terraform.io/signup/account)` account\rCreate a new '[Terraform Cloud organization ] (https://learn.hashicorp.com/terraform/cloud-getting-started/signup#create-your-organization)'\rCreate a new '[Terraform Cloud workspace ] (https://learn.hashicorp.com/terraform/cloud-getting-started/create-workspace)' named: arm-aws-ecs\rClick the CLI-driven workflow option\rIn the workspace, click arm-aws-ecs \u0026gt; Settings \u0026gt; General then enable '[local execution mode] (https://www.terraform.io/docs/cloud/workspaces/settings.html#execution-mode)'\rGo to the '[User Settings section] (https://www.terraform.io/docs/cloud/users-teams-organizations/users.html#user-settings)' in the Terraform Cloud Dashboard\rIn the User Settings section, Create a new '[Terraform API token] (https://www.terraform.io/docs/cloud/users-teams-organizations/users.html#api-tokens)' then copy and paste the token in a secure location for later use.\rWarning: Your Terraform Cloud API token must be protected and not shared with unauthorized parties to prevent exposure and unauthorized access.\nGreat, you have created and safely stored your newly created Terraform Cloud API Token.\n"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication.html",
	"title": "Lab 1 - User Pool API Authentication",
	"tags": [],
	"description": "",
	"content": "Lab 1 - User Pool API Authentication In this Lab you will setup a User Pool with a Hosted UI. You will explore OpenID and different approaches on how to configure and test OAuth 2.0. And we will implement it in nextjs app.\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.. Diagram\n"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/22_user_pool_configuration.html",
	"title": "User Pool Configuration",
	"tags": [],
	"description": "",
	"content": " Resouce Server We are now ready to further configure our user pool, we will begin by adding a resource server. As this lab will grant access to a Mock API at this stage we will create the resource and scope that will provide authenticated access to the get method of the API.\nSelect the App Integration tab and click on Create resource server Next we will enter as above the Resource server name, server identifier and Scope name then select Create resource server. App Client Settings We will now configure the call back URLs, OAuth flows and OAuth scopes.\nScroll down while still in the App integration tab to App client list and click on cfj-client” Then under Hosted UI select Edit There are a number of options to enable, ensure yours look the same as the image.\nFirst we add the Allowed sign-out URL to https://localhost\nUnder OAuth 2.0 Grant Types select\nAuthorization code grant and Implicit grant The implicit grant flow exposes OAuth tokens in the url. Although we are using it here for testing purposes only, we strongly reocmmend you only use the authroization code flow with PKCE for public clients.\nUnder OpenID Connect Scopes select\nOpenID Profile Email Under Custom Scopes select\ncfj-01/read Finally click Save changes\n"
},
{
	"uri": "//localhost:1313/1_moduleone/12_why_use_cognito.html",
	"title": "Why use Cognito",
	"tags": [],
	"description": "",
	"content": "Why use Cognito Integration with Other AWS Services Currently, there are many user management platforms, such as Clerk, Auth0, and others, that offer authentication features. Each of these services has unique advantages compared to AWS Cognito. However, when an application requires access to AWS resources, it’s essential to implement proper authorization and use Developer credentials/SDK to interact with those resources.\nCognito integrates seamlessly with other AWS services like API Gateway, Lambda, S3, and DynamoDB. This allows you to build comprehensive, robust, scalable, serverless applications where authentication and authorization are tightly coupled with your backend services.\nSource Image: Amazon Blog\nBenefits as cloud service "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/23_explore_openid_hosted_ui.html",
	"title": "Explore OpenID Config and Hosted UI",
	"tags": [],
	"description": "",
	"content": " OpenID Config Lets explore the published configuration and it’s format. This configuration follows a convention\nhttps://cognito-idp.{region}.amazonaws.com/{userpoolid}/.well-known/openid-configuration\nOn the console, on the left menu click on General settings, here you will find the user pool id: Copy this to construct your OpenID config URL and open this in your browser. https://cognito-idp.ap-southeast-1.amazonaws.com/ap-southeast-1_3JmHkB1jl/.well-known/openid-configuration\nHosted UI Lets explore the hosted UI and options.\nReturn to the AWS Console, Under the tab App integration click on cfj-client. From here click on View Hosted UI this will open a window/tab. Link will be https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=code\u0026amp;scope=cfj%2Fread\u0026#43;email\u0026#43;openid\u0026#43;profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nIn the New tab click Sign up we will be registering a new user. Fill out the registration form and ensure you use a real email address as a OTP ( One Time Password ) will be sent to this address to enable account confirmation. Click Sign up\nCheck your email inbox for the OTP and enter the value and click Confirm Account. The email you receive is minimal and not styled; this can all be customised if required. Once your account is confirmed you will be redirected back to your application, as we configured that url for this exercise to localhost and we are not hosting an application your browser will display the following. Take note of the URL it will be: https://localhost/?code=5768f05d-9077-4acb-a4d6-4978923f1995 though will be a different code. Let’s now look at the response when we change to implicit flow sign in. Change the response type value to token from code https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=token\u0026amp;scope=cfj%2Fread+email+openid+profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nAnd press enter to load the new URL, enter the user details you created previously and click Sign in “https://localhost/#id_token={a-large-id-token}\u0026amp;access_token={a-large-access-token}\u0026amp;expires_in=3600\u0026amp;token_type=Bearer” because your browser can’t connect to the server “localhost”.\nAuthorization in Postman Once postman launches, click the + to open a new tab. Once we have a new tab, click on the Authorisation item, then change the type to OAuth 2.0 Fill out the settings as per below, the Callback URL will be: https://localhost The Auth URL’s will be: https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/authorize and https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/token This can be found by navigating in Cognito console to App integration tab. Then in there, look for Cognito domain. The Client ID can be found by scrolling down in the App integration page to App client and analytics section. The ID will be listed next to your App client name.\nThen click Get New Access Token. This will pop up a mini browser requesting your credentials, use the credentials you created earlier to login and click Sign in. The mini browser will close and if you have followed all the steps correctly you will see this message: Click Proceed to view the tokens returned by Cognito. The token returned can be decoded at https://jwt.io for closer inspection this token is used to send to our service to authenticate and and provide course level access as defined by the scope. An example can be seen below. "
},
{
	"uri": "//localhost:1313/1_moduleone/13_how_authentication_works.html",
	"title": "How authentication works",
	"tags": [],
	"description": "",
	"content": "How authentication works with Amazon Cognito user pools and identity pools When your customer signs in to an Amazon Cognito user pool, your application receives JSON web tokens (JWTs).\nWhen your customer signs in to an identity pool, either with a user pool token or another provider, your application receives temporary AWS credentials.\nWith user pool sign-in, you can implement authentication and authorization entirely with an AWS SDK. If you don\u0026rsquo;t want to build your own user interface (UI) components, you can invoke a prebuilt web UI (the hosted UI) or the sign-in page for your third-party identity provider (IdP).\nUser pool API authentication and authorization with an AWS SDK API authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. They enter their username and password. The application invokes the method that makes an InitiateAuth API request. The request passes the user\u0026rsquo;s credentials to a user pool. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The user pool responds with a challenge that requests an MFA code. The application generates a prompt that collects the MFA code from the user. The application invokes the method that makes a RespondToAuthChallenge API request. The request passes the user\u0026rsquo;s MFA code. The user pool validates the user\u0026rsquo;s MFA code. The user pool responds with the user\u0026rsquo;s JWTs. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It invokes the InitiateAuth method again with the refresh token and retrieves new tokens. User pool authentication with the hosted UI Hosted UI authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a hosted UI sign-in prompt. They enter their username and password. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The hosted UI prompts the user to enter an MFA code. The user enters their MFA code. The hosted UI redirects the user to the application. The application collects the authorization code from the URL request parameter that the hosted UI appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. User pool authentication with a third-party identity provider Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The IdP prompts the user to enter an MFA code. The user enters their MFA code. The IdP redirects the user to the user pool with a SAML response or an authorization code. If the user passed an authorization code, the user pool silently exchanges the code for IdP tokens. The user pool validates the IdP tokens and redirects the user to the application with a new authorization code. The application collects the authorization code from the URL request parameter that the user pool appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. Identity pool authentication Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials. The IdP redirects the user to the application with a SAML response or an authorization code. If the user passed an authorization code, the application exchanges the code for IdP tokens. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs or assertion. The application invokes the method that makes a GetId API request. It passes the user\u0026rsquo;s token or assertion and requests an identity ID. The identity pool validates the token or assertion against configured identity providers. The identity pool returns an identity ID. The application invokes the method that makes a GetCredentialsForIdentity API request. It passes the user\u0026rsquo;s token or assertions and requests an IAM role. The identity pool generates a new JWT. The new JWT contains claims that request an IAM role. The identity pool determines the role based on the user\u0026rsquo;s request and the role-selection criteria in the identity pool configuration for the IdP. AWS Security Token Service (AWS STS) responds to the AssumeRoleWithWebIdentity request from the identity pool. The response contains API credentials for a temporary session with an IAM role. The application stores the session credentials. The user takes an action in the app that requires access-protected resources in AWS. The application applies the temporary credentials as signatures to API requests for the required AWS services. IAM evaluates the policies attached to the role in the credentials. It compares them to the request. The AWS service returns the requested data. The application renders the data in the user\u0026rsquo;s interface. The user views the data. "
},
{
	"uri": "//localhost:1313/3_modulethree.html",
	"title": "Partner Setup",
	"tags": [],
	"description": "",
	"content": "Partner Setup Module Three Heading This paragraph block should be an introduction to the module about requirements the partner may need for their audience members. Examples include signing up for the partner platform or installing an agent.\nModule Three Subheading This paragraph block should be utilized to briefly explain the submodules. Partner Setup Instructions A brief overview of submodule one.\nREMOVE: Every introduction page should include the following warning label.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\nNext Section Heading This paragraph block can optionally be utilized to lead into the next section of the workshop.\n"
},
{
	"uri": "//localhost:1313/4_modulefour.html",
	"title": "Hugo Framework and Markdown",
	"tags": [],
	"description": "",
	"content": "Hugo Framework and Markdown Setting Up The Workshop: AWS Hosted Or Self-paced By utilizing the Hugo language localization settings, directing the workshop towards a specific setup can be simplified. The Language setting in the config.toml file will allow you to distinguish between having one option or both. Commenting out one of the languages will hide all files that are related to that setup. By default, only the self-guided setup will be enabled. To enable switching, set disableLanguageSwitchingButton to false in the config.toml. If you want to have only the Event Engine setup, set the defaultContentLanguage at the top of the config.toml file to ee.\nThe Entry Point Of The Workshop And Naming Conventions All modifications should be done to files in the content folder. _index.md serves as the main entry point to your workshop. Adding modules can be done utilizing the format of #_title as a folder within content. By adding a number value to the title, this helps to keep the files structured in parity with the content of the workshop. A good practice for file naming is to have the folder be the module number and the submodule numbers add to that number reflecting their order. For example, the first module is 1_ModuleOne and the submodules would be 11_SubmoduleOne, 12_SubmoduleTwo, and so forth. To ensure the modules and submodules follow the correct structure order, adjust the \u0026ldquo;weight\u0026rdquo; value in the heading of the file to reflect the order you wish to use. Three module examples are included in this template with the second being split based upon the method of setup. The same rules apply for submodules. _index.md will be the entry point of that module. Submodules should be named with the format of {module number}{weight}_{title}.{language}.md. For example, 11_Foreword.md would be the first submodule of module one in the default language/setup. 31_PartnerSetup.ee.md would be the first submodule of module 3 in the EventEngine language/setup.\nWorking With Hugo Markdown and Shortcode The following links will supply you with all the reference documentation about Hugo markdown. For more experienced developers, inline HTML is also an option to add more customization. For example \u0026lt;p style='text-align: left;'\u0026gt; inline will allow you to adjust your text placement.\nMarkdown and Shortcode Resources The following links are your go-to resource for markdown and shortcode reference in building your workshop: Markdown cheat sheet https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Learn theme markdown https://learn.netlify.app/en/cont/markdown/ Menu extras and shortcuts https://learn.netlify.app/en/cont/menushortcuts/ Using Font Awesome Emoji\u0026rsquo;s https://learn.netlify.app/en/cont/icons/ to help your page pop Adding Images and Static Media Any images and static media to be included in the workshop need to be placed in the static/images folder. The format to display an image is as follows: ![Alternate Text](/images/imagename.jpg) For example, the markdown for this dog is ![An adorable puppy](/images/dog.jpg) and the image is in the static/images folder. Creating Links The format for creating links is [Link Display Text](http://example.com). For example, this link Hugo Framework was created using [Hugo Framework](https://gohugo.io/about/what-is-hugo/).\nThe \u0026ldquo;More\u0026rdquo; Menu Section This section of the menu on the left is designed to add additional resources that are related to the workshop but not necessarily part of the workshop itself. To modify these links, edit the sections marked [[menu.shortcuts]] in the config.toml located in the root folder. The \u0026ldquo;name\u0026rdquo; portion will be what is displayed in the menu. The \u0026ldquo;url\u0026rdquo; should be the address of the link. The \u0026ldquo;weight\u0026rdquo; setting will adjust the display order, similar to the other \u0026ldquo;weight\u0026rdquo; settings utilized in indexes and modules mentioned previously.\nEnsuring Pages Appear In Both Setup Versions A shortcut to creating the workshop with different setup versions is utilizing the localization functionality of Hugo. By adding a secondary extension to the filename, this file will be included in the specific version of the workshop. Currently, the base utilizes the format *.ee.md to signify that the page is to be used in the AWS EventEngine setup. Much of the time, the files will be the same as the content only differs at specific points. It is necessary to add them, however, to make sure that the common content is duplicated across both versions. If you wish to change the secondary extension or default version, this can be done in the config.toml file in the heading and [Languages] sections.\n"
},
{
	"uri": "//localhost:1313/1_moduleone/14_workshopprerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites This lab requires access to the AWS Console with a role that contains full permissions to:\nThe AWS Console Cognito API Gateway You will also require tools such as:\nnodejs Postman https://www.postman.com/ "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/25_restricting_api_access_.html",
	"title": "Restricting Api Access",
	"tags": [],
	"description": "",
	"content": "Deploy a mock API We will now deploy a Mock API and configure access to the read resource of that API.\nIn the AWS Console, in the unified search type API Gateway and click on the API Gateway Service icon. If this is your first visit to API Gateway you will see the welcome page, click Get Started You will be prompted with a dialog to deploy a prepopulated mock API, click OK You can peruse the Example API response, when you are satisfied, leave all settings as defaults and click Import If you have used API Gateway before, click Create API \u0026hellip;\u0026hellip;\nCreate Cognito Authorizer In API Gateway on the left menu click Authorizers , then click + Create New Authorizer input the name as Builder-Class, select Cognito and select your Cognito user pool in the drop down ( this should pre-populate when you click in the input field ).\nAdditionally add Authorization as the Token Source, ( note the spelling is Authorization ). Finally, click Create Your new Authorizer is ready, but before we attach this to the API let’s explore the test functionality. Click Test This will bring up a dialog, this is expecting what we would send to the API in an Authorization header. We will send a Bearer token that was generated earlier in Postman. Leave this dialog open. Return to Postman and return to the original Tab, Click Auth then click on the Available Tokens combo box, click Manage Tokens. From here scroll down until you see Token Type Bearer select and copy this token into your clipboard. If you double click the token it will select it all, do this carefully as the token is long. If you have left this idle for too long you may need to click Get New Access Token to retrieve a new token. Return to the AWS Console and in the input box type Bearer with one space and then paste the token and click test. Your Authorizer works end to end, now lets test this against the actual API. Attach Authorzier to the API We now have all the parts to add authentication to the API. In this section we will restrict access to the /pets end point.\nTo confirm this is all working as expected return to Postman and open a new tab, take the API URL ( you should still have this in a browser tab, if not navigate back to API Gateway, click Stages in the left menu and copy the URL from the highlighted section at the top next to Invoke URL ) and paste this in, click send to see the result. Return to the AWS Console, Navigate to API Gateway and select your API. In the left hand menu click Resources, in the Resources column, click/expand /pets then click on GET we will add authentication to only this resource which is the http GET verb on the sample API resource. Note: You may have to refresh the webpage for this new resource to appear. Click on the Authorization combo box select Builder-class (You may have refresh the page if you do not see it), then click the little tick to save. This will deploy a new option OAuth Scopes, click next to the default value which is NONE and type in petstore/read this is the OAuth scope we defined in Cognito earlier. Click the small tick to save. You screen should look like below: The settings are now ready but we have to deploy our API changes, click on Actions then Deploy API for the deployment stage select Prod and click deploy Test access api in postman To confirm this is all working as expected return to Postman, the same tab from earlier will be open, click Send to call the api again. This time the response will be:\nThis is expected, the API now require authorisation!\nThe API is expecting a new http header, the header required is: ` Key: Authorization Value: Bearer token\n`\nYou can manually add this by extracting the token as in earlier steps when we tested the Authorizer in the API Gateway console or you can click on the Authorization tab, for type select OAuth 2.0 This should re-populate the settings we entered. Available tokens will be empty, scroll down and click Get New Token, put in the username and password of the user created. Click Proceed, this time once the Manage Access Tokens dialog appears click Use Token. Click on the Headers tab and notice the additional header key and value. Click Send and the API will again return data! Create an IAM Role for your workspace Submodule Three Heading This paragraph block can be used to explain how to create a workspace if necessary. Example content guidance can be found at the bottom of the page.\nNext Section Heading This paragraph block can optionally be utilized to lead into the next section of the workshop.\nExample Content Guidance Create an IAM Role for your workspace Info: Starting from here, when you see command to be entered such as below, you will enter these commands into Cloud9 IDE. You can use the Copy to clipboard feature (right hand upper corner) to simply copy and paste into Cloud9. In order to paste, you can use Ctrl + V for Windows or Command + V for Mac.\nFollow this deep link to create an IAM role with Administrator access.\rConfirm that AWS service and EC2 are selected, then click Next to view permissions.\rConfirm that AdministratorAccess is checked, then click Next to review.\rEnter CircleCI-Workshop-Admin for the Name, and select Create Role createrole\r"
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/26_create_nextjs_app.html",
	"title": "Nextjs App With NextAuth",
	"tags": [],
	"description": "",
	"content": " Nextjs App With NextAuth Create NextJs App To get started, we first need to create a new Next.js project.\n$ npx create-next-app@latest cfj-cognito\rNow change into the new app directory \u0026amp; install some dependencies\nnpm install next-auth@beta\rConfigure NextAuth Create auth secret, it will add AUTH_SECRET to .env.local\nnpx auth secret\rCreate file auth.ts in folder libs, place the follwing content inside:\nimport NextAuth from \u0026#34;next-auth\u0026#34;; import CognitoProvider from \u0026#34;next-auth/providers/cognito\u0026#34;; export const { handlers, signIn, signOut, auth } = NextAuth({ // Configure one or more authentication providers providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, }), ], }) Create file route.ts in folder named app/api/auth/[\u0026hellip;nextauth] with content:\nimport {handlers} from \u0026#39;@/libs/auth\u0026#39;; export const {GET, POST} = handlers; As you can observe in the code snippet, all sensitive information is stored in an .env.local file. This practice is essential to prevent exposure of such details to the front-end users of our application. COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET get from App Client Setting in Cognito User Pool.\nFirst, go back to AWS -\u0026gt; Cognito and select \u0026ldquo;CFJ-01\u0026rdquo; pool.\nClick on the App integration tab and scroll to the bottom. You will see the App client list. Great! Here, you should find your \u0026ldquo;cfj-client\u0026rdquo;. Click on it. This is the place where you want to be: The issuer is a URL, that looks like this: https://cognito-idp.{region}.amazonaws.com/{PoolId}, where PoolId is from General Settings in Cognito Implementing User Authentication This section is extra, so enjoy it! First, create a new file inside app called auth-provider.tsx and put the following code inside:\n\u0026#34;use client\u0026#34;; import { SessionProvider } from \u0026#34;next-auth/react\u0026#34;; export default function AuthProvider({ children }: { children: React.ReactNode }) { return \u0026lt;SessionProvider\u0026gt;{children}\u0026lt;/SessionProvider\u0026gt;; } Update app/layout.tsx\nimport type { Metadata } from \u0026#34;next\u0026#34;; import { Inter } from \u0026#34;next/font/google\u0026#34;; import \u0026#34;./globals.css\u0026#34;; import AuthProvider from \u0026#34;@/components/auth-provider\u0026#34;; import Header from \u0026#34;@/components/header\u0026#34;; import Footer from \u0026#34;@/components/footer\u0026#34;; const inter = Inter({ subsets: [\u0026#34;latin\u0026#34;] }); export const metadata: Metadata = { title: \u0026#34;Create Next App\u0026#34;, description: \u0026#34;Generated by create next app\u0026#34;, }; export default function RootLayout({ children, }: Readonly\u0026lt;{ children: React.ReactNode; }\u0026gt;) { return ( \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body className={inter.className}\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col justify-between w-full h-full min-h-screen\u0026#34;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;AuthProvider\u0026gt; \u0026lt;main className=\u0026#34;flex-auto w-full max-w-3xl px-4 py-4 mx-auto sm:px-6 md:py-6\u0026#34;\u0026gt; {children} \u0026lt;/main\u0026gt; \u0026lt;/AuthProvider\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ); } Update app/page.tsx\nimport { auth } from \u0026#34;@/libs/auth\u0026#34; export default async function Index() { const session = await auth() return ( \u0026lt;div className=\u0026#34;flex flex-col gap-6\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-3xl font-bold\u0026#34;\u0026gt;NextAuth.js Example\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; This is an example site to demonstrate how to use NextAuth with Cognito \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col bg-gray-100 rounded-md\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;p-4 font-bold bg-gray-200 rounded-t-md\u0026#34;\u0026gt; Current Session \u0026lt;/div\u0026gt; \u0026lt;pre className=\u0026#34;py-6 px-4 whitespace-pre-wrap break-all\u0026#34;\u0026gt; {JSON.stringify(session, null, 2)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } For make some styles on app, I add more components and library. I can access code at \u0026hellip;\u0026hellip;.\nTesting To run app in https mode, update package.json in scripts tag:\n\u0026quot;dev\u0026quot;: \u0026quot;next dev --experimental-https\u0026quot;,\rRun app\nnpm run dev\rIt open page in browser at https://localhost:3000 Click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign in with Cognito\u0026rdquo;, browser will be redirect to hosted UI site. But now, we got error by redirect missmatch. Go to Hosted UI setting to update callback Url. Add new callback url: https://localhost:3000/api/auth/callback/cognito We will access test app again at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign In with Cognito\u0026rdquo; to process authentication at Hosted UI site Enter your crendentials, after authenticated, browser will be redirect to https://localhost:3000 "
},
{
	"uri": "//localhost:1313/2_lab_1_user_pool_api_authentication/27_social_login.html",
	"title": "Third Party Identity Provider",
	"tags": [],
	"description": "",
	"content": " Third Party Identity Provider Cognito user pools also allow you to set up social login for your users. This is very convenient in a world where most people have become accustomed to authentication via existing accounts such as Google, Facebook, Apple, etc. Source Image: https://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc\nSocial login setup To add google for authentication, we need to create OAuth client ID in Google API console. Open browser to access https://console.cloud.google.com/, select a project or create new project if not exists, and select \u0026ldquo;API \u0026amp; Service\u0026rdquo; in overview of project. Select \u0026ldquo;Credentials\u0026rdquo; tab and click \u0026ldquo;Create Crendentials\u0026rdquo; to create new OAuth Client Select Applicatio Type is Web Application, Enter name and set redirect Url. Redirect URI should be set to https:///oauth2/idpresponse. Click \u0026ldquo;Create\u0026rdquo; to create new crendentials. Store Client Id and Client Secret for setup in AWS Cognito. Go to \u0026ldquo;CFJ-01\u0026rdquo; User Pool, tab \u0026ldquo;Sign-in experience\u0026rdquo;, click \u0026ldquo;Add identity provider\u0026rdquo; Select \u0026ldquo;Google\u0026rdquo; and provider Client Id and Client Secret that has created above. Click \u0026ldquo;Add identity provider\u0026rdquo; to create Federated identity provider sign-in Login with Hosted UI We need to edit Hosted UI for using Google Authentication. In \u0026ldquo;CFJ-01\u0026rdquo; User pool, Select \u0026ldquo;cfj-client\u0026rdquo;, Click \u0026ldquo;Edit\u0026rdquo; on Hosted UI tab, add \u0026ldquo;Google\u0026rdquo; in \u0026ldquo;Identity provider\u0026rdquo; Click \u0026ldquo;Save\u0026rdquo;, it return to app client overview. On Hosted UI tab, Click \u0026ldquo;View Hosted UI\u0026rdquo; to see new Sign in with Google. Now you can authenticate with google in intergrated AWS Cognito.\nSeamless auth experience Now, we can authenticate users with Google, but they need to go to the Hosted UI site to continue with Google authentication. We will improve this by bypassing the Cognito-hosted UI for a seamless authentication experience for the user.\nAdd new provider in Next Auth configuration in libs/auth.ts\n.... providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, authorization: { params: { scope: \u0026#34;email profile openid cfj/read\u0026#34; } } }), ...([\u0026#34;Google\u0026#34;] as TProvider[]).map((providerName: TProvider) =\u0026gt; { const provider: Provider = getProvider(providerName); (provider as OAuth2Config\u0026lt;Profile\u0026gt;).authorization.params.scope = \u0026#34;email profile openid cfj/read\u0026#34;; return provider; }) ], .... Update redirect Url in Hosted UI setting Open browser at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo; and select \u0026ldquo;Sign in with CognitoGoogle\u0026rdquo; In user\u0026rsquo;s view, browser redirect to social page (Google), after alowed by user, it redirect to nextjs, bypass Hosted UI site.\nFor username/password login, we use NextAuth credentials provider with the AWS Cognito library\nAdd Credentials provider to \u0026rsquo;libs/auth.ts'\nCredentials({ id: \u0026#39;credentials\u0026#39;, name: \u0026#39;credentials\u0026#39;, credentials: { username: { label: \u0026#39;username\u0026#39;, type: \u0026#39;text\u0026#39; }, password: { label: \u0026#39;password\u0026#39;, type: \u0026#39;password\u0026#39; } }, async authorize(credentials) { if (!credentials) return null; const {username, password} = credentials; const secretHash = computeSecretHash(username as string, process.env.COGNITO_CLIENT_ID as string, process.env.COGNITO_CLIENT_SECRET as string); const cognito = new CognitoIdentityProviderClient({region: process.env.COGNITO_REGION}); const command = new InitiateAuthCommand({ AuthFlow: \u0026#39;USER_PASSWORD_AUTH\u0026#39;, ClientId: process.env.COGNITO_CLIENT_ID as string, AuthParameters: { USERNAME: username as string, PASSWORD: password as string, SECRET_HASH: secretHash, }, }); try { const response = await cognito.send(command); // You can access the ID, Access, and Refresh tokens here const idToken = response.AuthenticationResult?.IdToken; const accessToken = response.AuthenticationResult?.AccessToken; const refreshToken = response.AuthenticationResult?.RefreshToken; const expiresIn = response.AuthenticationResult?.ExpiresIn; let user: User = {} if (accessToken) { const userCommand = new GetUserCommand({ AccessToken: accessToken, }); const userResponse = await cognito.send(userCommand); user.id = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;sub\u0026#39;)?.Value as string | undefined; user.email = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;email\u0026#39;)?.Value as string | undefined; user.name = userResponse.Username; } return { ...user, token: {idToken, accessToken, refreshToken, expiresIn} } as User; } catch (error) { console.error(error); return null; } }, }) Now, user authentication avoids redirection to external pages (Hosted UI site), thereby enhancing the user experience and interface (UX/UI).\nReference: https://kelvinmwinuka.com/social-login-with-cognito-and-nextauth\nhttps://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc \u0026hellip; link github\n"
},
{
	"uri": "//localhost:1313/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]