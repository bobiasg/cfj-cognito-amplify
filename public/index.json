[
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/",
	"title": "Authentication with AWS Cognito",
	"tags": [],
	"description": "",
	"content": "Authentication with AWS Cognito Welcome Amazon Cognito is an identity platform that helps developers set up customer identity and access management (CIAM) for web and mobile apps. It allows users to sign up, sign in, and access applications, web portals, or digital services. Cognito acts as a user directory, authentication server, and authorization service. It can authenticate and authorize users from a built-in user directory, an enterprise directory, or consumer identity providers like Google and Facebook.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication/21_create_user_pool.html",
	"title": "Create Cognito User Pool",
	"tags": [],
	"description": "",
	"content": "Create Cognito User Pool Log into the AWS Console. In the AWS Console, open Amazon Cognito . Then click “Create a user pool” in the top right Select “User name, Email” under Cognito user pool sign-in options and hit Next Select “No MFA” and hit Next Leave the defaults for Step 3 and hit Next\nSet Send email with Cognito and hit Next Enter your User pool Name to “CFJ-01”, Check the Use the Cognito Hosted UI option You can specify a custom domain name for example auth.mycompany.com or use a subdomain of the AWS Cognito service ( amazoncognito.com ). Pick and enter random/unique subdomain. Enter your App client name to \u0026ldquo;cfj-client\u0026rdquo; and enter the Allowed callbak URLs to “https://localhost”, then hit Next Finally in the last step choose Create user pool "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/4_lab_3_identity_pool/41_create_identity_pool.html",
	"title": "Create Identity Pool",
	"tags": [],
	"description": "",
	"content": "Create Identity Pool From main Cognito page in the AWS console, Select Grant access to AWS services and then select Create identity pool Select \u0026ldquo;Authenticated access\u0026rdquo; and \u0026ldquo;Amazon Cognito user pool\u0026rdquo;. Click \u0026ldquo;Next\u0026rdquo; Select \u0026ldquo;Create a new IAM role\u0026rdquo;, enter \u0026ldquo;cfj-01\u0026rdquo; in role name Select User pool and App Client that was created in Lab 2 Enter pool name, and Click Next and Create identity pool Create S3 Ducket For Testing\nCreate S3 bucket and create two sub-directories “Engineering”, “Legal” Upload some test files in the bucket and sub-directories Edit bucket CORS permissions to allow cross-origin calls Important: This is for testing only, in production or real-world scenario you need to have proper CORS settings that allow only trusted origin.\n[\r{\r\u0026quot;AllowedHeaders\u0026quot;: [\u0026quot;*\u0026quot;],\r\u0026quot;AllowedMethods\u0026quot;: [\u0026quot;GET\u0026quot;],\r\u0026quot;AllowedOrigins\u0026quot;: [\u0026quot;*\u0026quot;],\r\u0026quot;ExposeHeaders\u0026quot;: []\r}\r]\r"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/3_lab_2_access_api/31_deploy_mock_api.html",
	"title": "Deploy Mock API",
	"tags": [],
	"description": "",
	"content": "Deploy Mock API In the AWS Console, in the unified search type API Gateway and click on the API Gateway Service icon. Select REST API by clicking Build Then select Example API and click Create API. The Mock API and endpoints are ready configure Enable CORS And deploy. We will now define a stage, click the deployment stage combobox and select [New Stage]. Provide a Stage name*, for this example use Prod, then click deploy. You will see the API endpoint that has been deployed, you can click on this and see the result of a get request in the browser, Change the URL and append /pets to the end and press enter you will see an example JSON response. An example URL will look like so: https://{random}.execute-api.{region}.amazonaws.com/prop/pets We now have a mock API the provides static pet data, next we will add authentication restricted by OAuth scope.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/1_moduleone.html",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction What you\u0026rsquo;ll be building Implementing Authentication in a Next.js 14 Application with AWS Cognito and NextAuth Integration\nWhen building a Next.js 14 application, implementing robust authentication is crucial for securing user data and managing access to various parts of your application. By integrating AWS Cognito with the NextAuth library, you can create a seamless sign-in/sign-up experience that leverages AWS\u0026rsquo;s secure and scalable user authentication service.\nIn this workshop, we’ll walk through how to set up Cognito for a simple web app. We’ll perform these steps:\nCreate a Cognito user pool Add sign-in pages Assign IAM roles to authenticated users Access AWS resources from the app This workshop should take you anywhere between 1 to 4 hours to complete.\nWhat you will learn During this workshop you use multiple AWS services including:\nAmazon Cognito Amazon S3 Amazon API Gateway Amazon Lambda TOC Lab 1: User Pool API Authentication Lab 2: Access API Lab 3: Identity Pool The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/1_moduleone/11_introduction_cognito.html",
	"title": "Introduction to Cognito",
	"tags": [],
	"description": "",
	"content": "Introduction to Cognito Amazon Cognito lets you easily add user sign-up and authentication to your mobile and web apps. Amazon Cognito also enables you to authenticate users through an external identity provider and provides temporary security credentials to access your app’s backend resources in AWS or any service behind Amazon API Gateway. Amazon Cognito works with external identity providers that support SAML or OpenID Connect, social identity providers (such as Facebook, Apple, Amazon) and you can also integrate your own identity provider.\nImage Source: Jerry Hargrove, awsgeek.com. License\nThe two components that follow make up Amazon Cognito. They operate independently or in tandem, based on your access needs for your users.\nUser pools Image Source: Amazon Docs\nCreate a user pool when you want to authenticate and authorize users to your app or API. User pools are a user directory with both self-service and administrator-driven user creation, management, and authentication. Your user pool can be an independent directory and OIDC identity provider (IdP), and an intermediate service provider (SP) to third-party providers of workforce and customer identities. You can provide single sign-on (SSO) in your app for your organization\u0026rsquo;s workforce identities in SAML 2.0 and OIDC IdPs with user pools. You can also provide SSO in your app for your organization\u0026rsquo;s customer identities in the public OAuth 2.0 identity stores Amazon, Google, Apple and Facebook. For more information about customer identity and access management (CIAM), see What is CIAM?.\nUser pools don’t require integration with an identity pool. From a user pool, you can issue authenticated JSON web tokens (JWTs) directly to an app, a web server, or an API.\nIdentity pools Image Source: Amazon Docs\nSet up an Amazon Cognito identity pool when you want to authorize authenticated or anonymous users to access your AWS resources. An identity pool issues AWS credentials for your app to serve resources to users. You can authenticate users with a trusted identity provider, like a user pool or a SAML 2.0 service. It can also optionally issue credentials for guest users. Identity pools use both role-based and attribute-based access control to manage your users’ authorization to access your AWS resources.\nIdentity pools don’t require integration with a user pool. An identity pool can accept authenticated claims directly from both workforce and consumer identity providers.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/4_lab_3_identity_pool/42_access_s3_nextjs.html",
	"title": "Access S3 in NextJS",
	"tags": [],
	"description": "",
	"content": "Access S3 Bucket NextJS App After sign-in and getting tokens, you need to get credentials from Identity Pool and use it to access S3 bucket.\nThis exercise is based on the APIs that has been created in 2. User Pool API Authentication .\nAdd new api in /api/aws/s3/route.ts :\nimport { auth } from \u0026#34;@/libs/auth\u0026#34;; import { CognitoIdentityClient, GetCredentialsForIdentityCommand, GetIdCommand } from \u0026#34;@aws-sdk/client-cognito-identity\u0026#34;; import { ListObjectsV2Command, S3Client, } from \u0026#34;@aws-sdk/client-s3\u0026#34; export async function GET(req: Request) { const session = await auth() if (!session) return Response.json({error: \u0026#39;Method Not Allowed\u0026#39;}, {status: 405}) //get credentials aws try { const credentials = await GetCredentials(session?.idToken) if (!credentials) return Response.json({error: \u0026#39;Id Token Not Allowed\u0026#39;}, {status: 405}) const client = new S3Client({ region: process.env.COGNITO_REGION as string, credentials: { accessKeyId: credentials?.AccessKeyId as string, secretAccessKey: credentials?.SecretKey as string, sessionToken: credentials?.SessionToken as string } }) const { Contents } = await client.send( new ListObjectsV2Command ({ Bucket: \u0026#39;cfj-ws-01\u0026#39;, // Prefix: `${credentials.identityId}/`, }) ) return Response.json(Contents); }catch(err) { return Response.json({error: err}, {status: 500}) } } async function GetCredentials(idToken: string) { const client = new CognitoIdentityClient({region: process.env.COGNITO_REGION}); const providerName = `cognito-idp.${process.env.COGNITO_REGION}.amazonaws.com/${process.env.COGNITO_USER_POOL_ID}` as string const getIdCommand = new GetIdCommand({ IdentityPoolId: process.env.COGNITO_IDENTITY_POOL_ID, Logins: { [providerName]: idToken, }, }); const idResponse = await client.send(getIdCommand); const credentialCommand = new GetCredentialsForIdentityCommand( { // GetCredentialsForIdentityInput IdentityId: idResponse.IdentityId, Logins: { // LoginsMap [providerName]: idToken// idToken, }, } ); const response = await client.send(credentialCommand); return response.Credentials; } You can now test invoking the API, after you sign-in with \u0026ldquo;Google\u0026rdquo; and get tokens from Cognito, click the Make S3 Request button. "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/3_lab_2_access_api/32_create_cognito_authorizer.html",
	"title": "Create Cognito Authorizer",
	"tags": [],
	"description": "",
	"content": "Cognito Authorizer Create Cognito Authorizer In API Gateway on the left menu click Authorizers , then click + Create New Authorizer input the name as cfj-ws-01, select Cognito and select your Cognito user pool in the drop down ( this should pre-populate when you click in the input field ).\nAdditionally add Authorization as the Token Source, ( note the spelling is Authorization ). Finally, click Create authorizer Your new Authorizer is ready, but before we attach this to the API let’s explore the test functionality. Click Test authorizer. This will bring up a dialog, this is expecting what we would send to the API in an Authorization header. We will send a Bearer token that was generated earlier in Postman. Leave this dialog open. Return to Postman, click Get New Access Token to retrieve a new token. Return to the AWS Console and in the input box type Bearer with one space and then paste the token and click Test authorizer. Your Authorizer works end to end, now lets test this against the actual API. Attach Authorizer to the API We now have all the parts to add authentication to the API. In this section we will restrict access to the /pets end point.\nTo confirm this is all working as expected return to Postman and open a new tab, take the API URL ( you should still have this in a browser tab, if not navigate back to API Gateway, click Stages in the left menu and copy the URL from the highlighted section at the top next to Invoke URL ) and paste this in, click send to see the result Return to the AWS Console, Navigate to API Gateway and select your API. In the left hand menu click Resources, in the Resources column, click/expand /pets then click on GET we will add authentication to only this resource which is the http GET verb on the sample API resource. Note: You may have to refresh the webpage for this new Click on the Authorization combo box, select cfj-ws-01 (You may have refresh the page if you do not see it), add a new option OAuth Scopes: cfj/read, this is the OAuth scope we defined in Cognito earlier. Click the small tick to save. You screen should look like below: The settings are now ready but we have to deploy our API changes, click on Actions then Deploy API, for the deployment stage select prod and click deploy "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication.html",
	"title": "Lab 1 - User Pool API Authentication",
	"tags": [],
	"description": "",
	"content": "Lab 1 - User Pool API Authentication In this Lab you will setup a User Pool with a Hosted UI. You will explore OpenID and different approaches on how to configure and test OAuth 2.0. And we will implement it in nextjs app.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication/22_user_pool_configuration.html",
	"title": "User Pool Configuration",
	"tags": [],
	"description": "",
	"content": " Resouce Server We are now ready to further configure our user pool, we will begin by adding a resource server. As this lab will grant access to a Mock API at this stage we will create the resource and scope that will provide authenticated access to the get method of the API.\nSelect the App Integration tab and click on Create resource server Next we will enter as above the Resource server name, server identifier and Scope name then select Create resource server. App Client Settings We will now configure the call back URLs, OAuth flows and OAuth scopes.\nScroll down while still in the App integration tab to App client list and click on \u0026ldquo;cfj-client\u0026rdquo; Then under Hosted UI select Edit There are a number of options to enable, ensure yours look the same as the image.\nFirst we add the Allowed sign-out URL to https://localhost\nUnder OAuth 2.0 Grant Types select\nAuthorization code grant and Implicit grant The implicit grant flow exposes OAuth tokens in the url. Although we are using it here for testing purposes only, we strongly reocmmend you only use the authroization code flow with PKCE for public clients.\nUnder OpenID Connect Scopes select\nOpenID Profile Email Under Custom Scopes select\ncfj-01/read Finally click Save changes\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/1_moduleone/12_why_use_cognito.html",
	"title": "Why use Cognito",
	"tags": [],
	"description": "",
	"content": "Why use Cognito Integration with Other AWS Services Currently, there are many user management platforms, such as Clerk, Auth0, etc, that offer authentication features. Each of these services has unique advantages compared to AWS Cognito. However, when an application requires access to AWS resources, it’s essential to implement proper authorization and use Developer credentials/SDK to interact with those resources.\nCognito integrates seamlessly with other AWS services like API Gateway, Lambda, S3, and DynamoDB. This allows you to build comprehensive, robust, scalable, serverless applications where authentication and authorization are tightly coupled with your backend services.\nSource Image: Amazon Blog\nBenefits as cloud service Scalability and Reliability Security Customizable User Management Cost-Effectiveness Ease of Use and Quick Setup User Experience "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/3_lab_2_access_api/33_access_api_nextjs.html",
	"title": "Access API in NextJS",
	"tags": [],
	"description": "",
	"content": "Access API in NextJS Postman To confirm this is all working as expected return to Postman, the same tab from earlier will be open, click Send to call the api again. This time the response will be: This is expected, the API now require authorisation!\nYou can manually add this by extracting the token as in earlier steps when we tested the Authorizer in the API Gateway console or you can click on the Authorization tab, for type select OAuth 2.0 This should re-populate the settings we entered. Available tokens will be empty, scroll down and click Get New Token, put in the username and password of the user created. Click Proceed, this time once the Manage Access Tokens dialog appears click Use Token.\nClick on the Headers tab and notice the additional header key and value. Click Send and the API will again return data! NextJS App After sign-in and getting tokens, you can use these tokens to authorize access to protected APIs on API Gateway.\nThis exercise is based on the APIs that has been created in 2. User Pool API Authentication.\nAdd button in dashboard page with click handler:\nconst makeRequestWithToken = async () =\u0026gt; { try { const response = await fetch(\u0026#39;https://06gfqqzl55.execute-api.ap-southeast-1.amazonaws.com/prod/pets\u0026#39;,{ method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer \u0026#39; + session?.accessToken, }, }) const data = await response.json() setApiResponse(JSON.stringify(data, null, 2)) } catch (error) { setApiResponse(\u0026#34;Failed to fetch data: \u0026#34; + error) } } You can now test invoking the API, after you sign-in with \u0026ldquo;Google\u0026rdquo; and get tokens from Cognito, click the Make API Request button. Notice the access-token is added to the authorization header and the endpoint responds with the expected results: Currently, when you sign in by username/password, you will get error because in crendentials process, we does not process to request scope: cfj/read "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/4_lab_3_identity_pool/43_additional_claims.html",
	"title": "Enrich user token with additional claims",
	"tags": [],
	"description": "",
	"content": "Enrich user token with additional claims Add Claim with Lambda In this activity, we will enrich users token with additional claims using Pre Token Generation lambda trigger. This trigger will add “department” claim to the token as users sign-in. In real-world scenario, this could be based on a backend check to verify user’s department or it could be a custom claim in user’s profile that can be only modified by administrator.\nNavigate to the Lambda console and click on the Create Function button. Select Author from scratch and give the lambda function a name. Select Node.js runtime. In the lambda window, click on the index.js to select it and replace the code with the following code. Click on Deploy when done.\nexports.handler = (event, context, callback) =\u0026gt; { event.response = { claimsOverrideDetails: { claimsToAddOrOverride: { department: \u0026#39;Legal\u0026#39;, }, }, }; callback(null, event); }; Navigate back to the Cognito console, select your \u0026ldquo;CFJ-01\u0026rdquo; user pool, in User pool properties tab, Add Lambda Trigger Select Authentication, Pre Token Generation trigger, select lambda function has just created. Click on the Save Changes button. Go back to postman to get new token, get idtoken and use https://jwt.io to decode it. Adding fine-grained access control We will add fine-grained access control to allow users access to S3 resources based on their department.\nNavigate to the Cognito console and select \u0026ldquo;cfj-identity-ws-01\u0026rdquo; Identity pool. In Identity providers tab, select Amazon Cognito user pool, Click on Edit on Attributes for access control. Select \u0026ldquo;Use custom mappings\u0026rdquo; and add new attribute map Edit the trust policy of IAM role mapped to your identity pool to allow “sts:TagSession”. Replace identity-pool-id below with your Identity Pool ID\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: \u0026#34;cognito-identity.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: [\u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;sts:TagSession\u0026#34;], \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;cognito-identity.amazonaws.com:aud\u0026#34;: \u0026#34;identity-pool-id\u0026#34; }, \u0026#34;ForAnyValue:StringLike\u0026#34;: { \u0026#34;cognito-identity.amazonaws.com:amr\u0026#34;: \u0026#34;authenticated\u0026#34; } } } ] } Edit the IAM role mapped to your identity pool to allow listing objects under user’s department only as below\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:List*\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: \u0026#34;${aws:PrincipalTag/department}\u0026#34; } } } ] } Now test accessing S3 once again by sign-out, sign-in again and then navigate to \u0026ldquo;Make S3 Request\u0026rdquo; button. You should see 403 error returning from this call indicating that access is denied.\nTry \u0026ldquo;Make S3 Request: Legal\u0026rdquo; button. This call should succeed since you are trying to list files under the department that exists in token.\nWhat happened here? Why can I list files under “Legal” prefix but not under \u0026ldquo;Engineering\u0026rdquo; ?\nBecause user’s token has a “department” claim with the value “Legal” (we added this claim from Pre Token Generation trigger).\nAnd we configured the identity pool to pass this claim as session tag with the name “department”, then we modified the IAM policy to allow access only if the requested prefix matches the “department” session tag. "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication/23_explore_openid_hosted_ui.html",
	"title": "Explore OpenID Config and Hosted UI",
	"tags": [],
	"description": "",
	"content": " OpenID Config Lets explore the published configuration and it’s format. This configuration follows a convention\nhttps://cognito-idp.{region}.amazonaws.com/{userpoolid}/.well-known/openid-configuration\nOn the console, on the left menu click on General settings, here you will find the user pool id: Copy this to construct your OpenID config URL and open this in your browser. https://cognito-idp.ap-southeast-1.amazonaws.com/ap-southeast-1_3JmHkB1jl/.well-known/openid-configuration\nHosted UI Return to the AWS Console, Under the tab App integration click on cfj-client. From here click on View Hosted UI this will open a window/tab. Link will be https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=code\u0026amp;scope=cfj%2Fread\u0026#43;email\u0026#43;openid\u0026#43;profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nIn the New tab click Sign up we will be registering a new user. Fill out the registration form and ensure you use a real email address as a OTP ( One Time Password ) will be sent to this address to enable account confirmation. Click Sign up\nCheck your email inbox for the OTP and enter the value and click Confirm Account. The email you receive is minimal and this can all be customised if required. Once your account is confirmed you will be redirected back to your application, as we configured that url for this exercise to localhost and we are not hosting an application your browser will display the following. Take note of the URL it will be: https://localhost/?code=5768f05d-9077-4acb-a4d6-4978923f1995 though will be a different code. Let’s now look at the response when we change to implicit flow sign in. Change the response type value to token from code https://cfj-01.auth.ap-southeast-1.amazoncognito.com/oauth2/authorize?client_id=xxxx\u0026amp;response_type=token\u0026amp;scope=cfj%2Fread+email+openid+profile\u0026amp;redirect_uri=https%3A%2F%2Flocalhost\nAnd press enter to load the new URL, enter the user details you created previously and click Sign in “https://localhost/#id_token={a-large-id-token}\u0026amp;access_token={a-large-access-token}\u0026amp;expires_in=3600\u0026amp;token_type=Bearer” because your browser can’t connect to the server “localhost”.\nAuthorization in Postman Once postman launches, click the + to open a new tab. Once we have a new tab, click on the Authorization, then change the type to OAuth 2.0 Fill out the settings as per below:\nthe Callback URL will be: https://localhost The Auth URL’s will be: https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/authorize and https://{your-cognito-domain}.auth.{your-region}.amazoncognito.com/oauth2/token This can be found by navigating in Cognito console to App integration tab. Then in there, look for Cognito domain. The Client ID can be found by scrolling down in the App integration page to App client and analytics section. The ID will be listed next to your App client name.\nThen click Get New Access Token. This will pop up a mini browser requesting your credentials, use the credentials you created earlier to login and click Sign in. The mini browser will close and if you have followed all the steps correctly you will see this message: Click Proceed to view the tokens returned by Cognito. The token returned can be decoded at https://jwt.io for closer inspection this token is used to send to our service to authenticate and and provide course level access as defined by the scope. An example can be seen below. "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/1_moduleone/13_how_authentication_works.html",
	"title": "How authentication works",
	"tags": [],
	"description": "",
	"content": "How authentication works with Amazon Cognito user pools and identity pools When your customer signs in to an Amazon Cognito user pool, your application receives JSON web tokens (JWTs).\nWhen your customer signs in to an identity pool, either with a user pool token or another provider, your application receives temporary AWS credentials.\nWith user pool sign-in, you can implement authentication and authorization entirely with an AWS SDK. If you don\u0026rsquo;t want to build your own user interface (UI) components, you can invoke a prebuilt web UI (the hosted UI) or the sign-in page for your third-party identity provider (IdP).\nUser pool API authentication and authorization with an AWS SDK API authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. They enter their username and password. The application invokes the method that makes an InitiateAuth API request. The request passes the user\u0026rsquo;s credentials to a user pool. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The user pool responds with a challenge that requests an MFA code. The application generates a prompt that collects the MFA code from the user. The application invokes the method that makes a RespondToAuthChallenge API request. The request passes the user\u0026rsquo;s MFA code. The user pool validates the user\u0026rsquo;s MFA code. The user pool responds with the user\u0026rsquo;s JWTs. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It invokes the InitiateAuth method again with the refresh token and retrieves new tokens. User pool authentication with the hosted UI Hosted UI authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a hosted UI sign-in prompt. They enter their username and password. The user pool validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The hosted UI prompts the user to enter an MFA code. The user enters their MFA code. The hosted UI redirects the user to the application. The application collects the authorization code from the URL request parameter that the hosted UI appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. User pool authentication with a third-party identity provider Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials and determines that the user has activated multi-factor authentication (MFA). The IdP prompts the user to enter an MFA code. The user enters their MFA code. The IdP redirects the user to the user pool with a SAML response or an authorization code. If the user passed an authorization code, the user pool silently exchanges the code for IdP tokens. The user pool validates the IdP tokens and redirects the user to the application with a new authorization code. The application collects the authorization code from the URL request parameter that the user pool appended to the callback URL. The application requests tokens with the authorization code. The token endpoint returns JWTs to the application. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs. The application displays the requested access-controlled component. The user views their content. Later, the user\u0026rsquo;s access token has expired, and they request to view an access-controlled component. The application determines that the user\u0026rsquo;s session should persist. It requests new tokens from the token endpoint with the refresh token. Identity pool authentication Federated authentication flow A user accesses your application. They select a \u0026ldquo;Sign in\u0026rdquo; link. The application directs the user to a sign-in prompt with their IdP. They enter their username and password. The IdP validates the user\u0026rsquo;s credentials. The IdP redirects the user to the application with a SAML response or an authorization code. If the user passed an authorization code, the application exchanges the code for IdP tokens. The application decodes, validates, and stores or caches the user\u0026rsquo;s JWTs or assertion. The application invokes the method that makes a GetId API request. It passes the user\u0026rsquo;s token or assertion and requests an identity ID. The identity pool validates the token or assertion against configured identity providers. The identity pool returns an identity ID. The application invokes the method that makes a GetCredentialsForIdentity API request. It passes the user\u0026rsquo;s token or assertions and requests an IAM role. The identity pool generates a new JWT. The new JWT contains claims that request an IAM role. The identity pool determines the role based on the user\u0026rsquo;s request and the role-selection criteria in the identity pool configuration for the IdP. AWS Security Token Service (AWS STS) responds to the AssumeRoleWithWebIdentity request from the identity pool. The response contains API credentials for a temporary session with an IAM role. The application stores the session credentials. The user takes an action in the app that requires access-protected resources in AWS. The application applies the temporary credentials as signatures to API requests for the required AWS services. IAM evaluates the policies attached to the role in the credentials. It compares them to the request. The AWS service returns the requested data. The application renders the data in the user\u0026rsquo;s interface. The user views the data. "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/3_lab_2_access_api.html",
	"title": "Lab 2 - Access Protected API",
	"tags": [],
	"description": "",
	"content": "Access Protected API We will now deploy a Mock API and configure access to the read resource of that API. API has protected by Cognito Authorizer in API Gateway.\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/4_lab_3_identity_pool.html",
	"title": "Lab 3 - Identity Pool",
	"tags": [],
	"description": "",
	"content": "Lab 3 - Identity Pool Activities in this coding exercise are based on resources create in previous exercises:\nLab 1: User Pool API Authentication Lab 2: Access API "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/1_moduleone/14_workshopprerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites This lab requires access to the AWS Console with a role that contains full permissions to:\nThe AWS Console Cognito API Gateway S3 Lambda You will also require tools such as:\nnodejs/nextjs Postman https://www.postman.com/ "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication/26_create_nextjs_app.html",
	"title": "Nextjs App With NextAuth",
	"tags": [],
	"description": "",
	"content": " Nextjs App With NextAuth Create NextJs App To get started, we first need to create a new Next.js project.\n$ npx create-next-app@latest cfj-cognito\rNow change into the new app directory \u0026amp; install some dependencies\nnpm install next-auth@beta\rConfigure NextAuth Create auth secret, it will add AUTH_SECRET to .env.local\nnpx auth secret\rCreate file auth.ts in folder libs, place the follwing content inside:\nimport NextAuth from \u0026#34;next-auth\u0026#34;; import CognitoProvider from \u0026#34;next-auth/providers/cognito\u0026#34;; export const { handlers, signIn, signOut, auth } = NextAuth({ // Configure one or more authentication providers providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, }), ], }) Create file route.ts in folder named app/api/auth/[\u0026hellip;nextauth] with content:\nimport {handlers} from \u0026#39;@/libs/auth\u0026#39;; export const {GET, POST} = handlers; As you can observe in the code snippet, all sensitive information is stored in an .env.local file. This practice is essential to prevent exposure of such details to the front-end users of our application. COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET get from App Client Setting in Cognito User Pool.\nFirst, go back to AWS -\u0026gt; Cognito and select \u0026ldquo;CFJ-01\u0026rdquo; pool.\nClick on the App integration tab and scroll to the bottom. You will see the App client list. Great! Here, you should find your \u0026ldquo;cfj-client\u0026rdquo;. Click on it. This is the place where you want to be: The issuer is a URL, that looks like this: https://cognito-idp.{region}.amazonaws.com/{PoolId}, where PoolId is from General Settings in Cognito Implementing User Authentication This section is extra, so enjoy it! First, create a new file inside app called auth-provider.tsx and put the following code inside:\n\u0026#34;use client\u0026#34;; import { SessionProvider } from \u0026#34;next-auth/react\u0026#34;; export default function AuthProvider({ children }: { children: React.ReactNode }) { return \u0026lt;SessionProvider\u0026gt;{children}\u0026lt;/SessionProvider\u0026gt;; } Update app/layout.tsx\nimport type { Metadata } from \u0026#34;next\u0026#34;; import { Inter } from \u0026#34;next/font/google\u0026#34;; import \u0026#34;./globals.css\u0026#34;; import AuthProvider from \u0026#34;@/components/auth-provider\u0026#34;; import Header from \u0026#34;@/components/header\u0026#34;; import Footer from \u0026#34;@/components/footer\u0026#34;; const inter = Inter({ subsets: [\u0026#34;latin\u0026#34;] }); export const metadata: Metadata = { title: \u0026#34;Create Next App\u0026#34;, description: \u0026#34;Generated by create next app\u0026#34;, }; export default function RootLayout({ children, }: Readonly\u0026lt;{ children: React.ReactNode; }\u0026gt;) { return ( \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body className={inter.className}\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col justify-between w-full h-full min-h-screen\u0026#34;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;AuthProvider\u0026gt; \u0026lt;main className=\u0026#34;flex-auto w-full max-w-3xl px-4 py-4 mx-auto sm:px-6 md:py-6\u0026#34;\u0026gt; {children} \u0026lt;/main\u0026gt; \u0026lt;/AuthProvider\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ); } Update app/page.tsx\nimport { auth } from \u0026#34;@/libs/auth\u0026#34; export default async function Index() { const session = await auth() return ( \u0026lt;div className=\u0026#34;flex flex-col gap-6\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-3xl font-bold\u0026#34;\u0026gt;NextAuth.js Example\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; This is an example site to demonstrate how to use NextAuth with Cognito \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col bg-gray-100 rounded-md\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;p-4 font-bold bg-gray-200 rounded-t-md\u0026#34;\u0026gt; Current Session \u0026lt;/div\u0026gt; \u0026lt;pre className=\u0026#34;py-6 px-4 whitespace-pre-wrap break-all\u0026#34;\u0026gt; {JSON.stringify(session, null, 2)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } For make some styles on app, I add more components and library. you can access code at https://github.com/bobiasg/cfj-cognito\nTesting To run app in https mode, update package.json in scripts tag:\n\u0026quot;dev\u0026quot;: \u0026quot;next dev --experimental-https\u0026quot;,\rRun app\nnpm run dev\rIt open page in browser at https://localhost:3000 Click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign in with Cognito\u0026rdquo;, browser will be redirect to hosted UI site. But now, we got error by redirect missmatch. Go to Hosted UI setting to update callback Url. Add new callback url: https://localhost:3000/api/auth/callback/cognito We will access test app again at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo;, and click \u0026ldquo;Sign In with Cognito\u0026rdquo; to process authentication at Hosted UI site Enter your crendentials, after authenticated, browser will be redirect to https://localhost:3000 "
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/2_lab_1_user_pool_api_authentication/27_social_login.html",
	"title": "Third Party Identity Provider",
	"tags": [],
	"description": "",
	"content": " Third Party Identity Provider Cognito user pools also allow you to set up social login for your users. This is very convenient in a world where most people have become accustomed to authentication via existing accounts such as Google, Facebook, Apple, etc. Source Image: https://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc\nSocial login setup To add google for authentication, we need to create OAuth client ID in Google API console. Open browser to access https://console.cloud.google.com/, select a project or create new project if not exists, and select \u0026ldquo;API \u0026amp; Service\u0026rdquo; in overview of project. Select \u0026ldquo;Credentials\u0026rdquo; tab and click \u0026ldquo;Create Crendentials\u0026rdquo; to create new OAuth Client Select Applicatio Type is Web Application, Enter name and set redirect Url. Redirect URI should be set to https:///oauth2/idpresponse. Click \u0026ldquo;Create\u0026rdquo; to create new crendentials. Store Client Id and Client Secret for setup in AWS Cognito. Go to \u0026ldquo;CFJ-01\u0026rdquo; User Pool, tab \u0026ldquo;Sign-in experience\u0026rdquo;, click \u0026ldquo;Add identity provider\u0026rdquo; Select \u0026ldquo;Google\u0026rdquo; and provider Client Id and Client Secret that has created above. Click \u0026ldquo;Add identity provider\u0026rdquo; to create Federated identity provider sign-in Login with Hosted UI We need to edit Hosted UI for using Google Authentication. In \u0026ldquo;CFJ-01\u0026rdquo; User pool, Select \u0026ldquo;cfj-client\u0026rdquo;, Click \u0026ldquo;Edit\u0026rdquo; on Hosted UI tab, add \u0026ldquo;Google\u0026rdquo; in \u0026ldquo;Identity provider\u0026rdquo; Click \u0026ldquo;Save\u0026rdquo;, it return to app client overview. On Hosted UI tab, Click \u0026ldquo;View Hosted UI\u0026rdquo; to see new Sign in with Google. Now you can authenticate with google in intergrated AWS Cognito.\nSeamless auth experience Now, we can authenticate users with Google, but they need to go to the Hosted UI site to continue with Google authentication. We will improve this by bypassing the Cognito-hosted UI for a seamless authentication experience for the user.\nAdd new provider in Next Auth configuration in libs/auth.ts\n.... providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, authorization: { params: { scope: \u0026#34;email profile openid cfj/read\u0026#34; } } }), ...([\u0026#34;Google\u0026#34;] as TProvider[]).map((providerName: TProvider) =\u0026gt; { const provider: Provider = getProvider(providerName); (provider as OAuth2Config\u0026lt;Profile\u0026gt;).authorization.params.scope = \u0026#34;email profile openid cfj/read\u0026#34;; return provider; }) ], .... Update redirect Url in Hosted UI setting Open browser at https://localhost:3000, click \u0026ldquo;Sign In\u0026rdquo; and select \u0026ldquo;Sign in with CognitoGoogle\u0026rdquo; In user\u0026rsquo;s view, browser redirect to social page (Google), after alowed by user, it redirect to nextjs, bypass Hosted UI site.\nFor username/password login, we use NextAuth credentials provider with the AWS Cognito library\nAdd Credentials provider to \u0026lsquo;libs/auth.ts\u0026rsquo;\nCredentials({ id: \u0026#39;credentials\u0026#39;, name: \u0026#39;credentials\u0026#39;, credentials: { username: { label: \u0026#39;username\u0026#39;, type: \u0026#39;text\u0026#39; }, password: { label: \u0026#39;password\u0026#39;, type: \u0026#39;password\u0026#39; } }, async authorize(credentials) { if (!credentials) return null; const {username, password} = credentials; const secretHash = computeSecretHash(username as string, process.env.COGNITO_CLIENT_ID as string, process.env.COGNITO_CLIENT_SECRET as string); const cognito = new CognitoIdentityProviderClient({region: process.env.COGNITO_REGION}); const command = new InitiateAuthCommand({ AuthFlow: \u0026#39;USER_PASSWORD_AUTH\u0026#39;, ClientId: process.env.COGNITO_CLIENT_ID as string, AuthParameters: { USERNAME: username as string, PASSWORD: password as string, SECRET_HASH: secretHash, }, }); try { const response = await cognito.send(command); // You can access the ID, Access, and Refresh tokens here const idToken = response.AuthenticationResult?.IdToken; const accessToken = response.AuthenticationResult?.AccessToken; const refreshToken = response.AuthenticationResult?.RefreshToken; const expiresIn = response.AuthenticationResult?.ExpiresIn; let user: User = {} if (accessToken) { const userCommand = new GetUserCommand({ AccessToken: accessToken, }); const userResponse = await cognito.send(userCommand); user.id = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;sub\u0026#39;)?.Value as string | undefined; user.email = userResponse.UserAttributes?.find(item =\u0026gt; item.Name === \u0026#39;email\u0026#39;)?.Value as string | undefined; user.name = userResponse.Username; } return { ...user, token: {idToken, accessToken, refreshToken, expiresIn} } as User; } catch (error) { console.error(error); return null; } }, }) Now, user authentication avoids redirection to external pages (Hosted UI site), thereby enhancing the user experience and interface (UX/UI). Reference: https://kelvinmwinuka.com/social-login-with-cognito-and-nextauth\nhttps://awskarthik82.medium.com/how-to-integrate-aws-cognito-with-google-social-login-fd379ff644cc\nSource code: https://github.com/bobiasg/cfj-cognito\n"
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bobiasg.github.io/cfj-cognito-amplify/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]